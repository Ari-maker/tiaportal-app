__BRYTHON__.use_VFS = true;
var scripts = {"$timestamp": 1692968632187, "clr_loader.hostfxr": [".py", "import sys\nfrom pathlib import Path\nfrom typing import Generator,Tuple\n\nfrom .ffi import ffi,load_hostfxr\nfrom .types import Runtime,RuntimeInfo,StrOrPath\nfrom .util import check_result\n\n__all__=[\"DotnetCoreRuntime\"]\n\n_IS_SHUTDOWN=False\n\n\nclass DotnetCoreRuntime(Runtime):\n def __init__(self,runtime_config:Path,dotnet_root:Path,**params:str):\n  self._handle=None\n  \n  if _IS_SHUTDOWN:\n   raise RuntimeError(\"Runtime can not be reinitialized\")\n   \n  self._dotnet_root=Path(dotnet_root)\n  self._dll=load_hostfxr(self._dotnet_root)\n  self._is_initialized=False\n  self._handle=_get_handle(self._dll,self._dotnet_root,runtime_config)\n  self._load_func=_get_load_func(self._dll,self._handle)\n  \n  for key,value in params.items():\n   self[key]=value\n   \n   \n  self._version=\"<undefined>\"\n  \n @property\n def dotnet_root(self)->Path:\n  return self._dotnet_root\n  \n @property\n def is_initialized(self)->bool:\n  return self._is_initialized\n  \n @property\n def is_shutdown(self)->bool:\n  return _IS_SHUTDOWN\n  \n def __getitem__(self,key:str)->str:\n  if self.is_shutdown:\n   raise RuntimeError(\"Runtime is shut down\")\n  buf=ffi.new(\"char_t**\")\n  res=self._dll.hostfxr_get_runtime_property_value(\n  self._handle,encode(key),buf\n  )\n  if res !=0:\n   raise KeyError(key)\n   \n  return decode(buf[0])\n  \n def __setitem__(self,key:str,value:str)->None :\n  if self.is_initialized:\n   raise RuntimeError(\"Already initialized\")\n   \n  res=self._dll.hostfxr_set_runtime_property_value(\n  self._handle,encode(key),encode(value)\n  )\n  check_result(res)\n  \n def __iter__(self)->Generator[Tuple[str,str],None ,None ]:\n  if self.is_shutdown:\n   raise RuntimeError(\"Runtime is shut down\")\n  max_size=100\n  size_ptr=ffi.new(\"size_t*\")\n  size_ptr[0]=max_size\n  \n  keys_ptr=ffi.new(\"char_t*[]\",max_size)\n  values_ptr=ffi.new(\"char_t*[]\",max_size)\n  \n  res=self._dll.hostfxr_get_runtime_properties(\n  self._handle,size_ptr,keys_ptr,values_ptr\n  )\n  check_result(res)\n  \n  for i in range(size_ptr[0]):\n   yield (decode(keys_ptr[i]),decode(values_ptr[i]))\n   \n def _get_callable(self,assembly_path:StrOrPath,typename:str,function:str):\n \n \n  self._is_initialized=True\n  \n  \n  assembly_path=Path(assembly_path)\n  assembly_name=assembly_path.stem\n  typename=f\"{typename}, {assembly_name}\"\n  \n  delegate_ptr=ffi.new(\"void**\")\n  res=self._load_func(\n  encode(str(assembly_path)),\n  encode(typename),\n  encode(function),\n  ffi.NULL,\n  ffi.NULL,\n  delegate_ptr,\n  )\n  check_result(res)\n  return ffi.cast(\"component_entry_point_fn\",delegate_ptr[0])\n  \n def _check_initialized(self)->None :\n  if self._handle is None :\n   raise RuntimeError(\"Runtime is shut down\")\n  elif not self._is_initialized:\n   raise RuntimeError(\"Runtime is not initialized\")\n   \n def shutdown(self)->None :\n  if self._handle is not None :\n   self._dll.hostfxr_close(self._handle)\n   self._handle=None\n   \n def info(self):\n  return RuntimeInfo(\n  kind=\"CoreCLR\",\n  version=self._version,\n  initialized=self._handle is not None ,\n  shutdown=self._handle is None ,\n  properties=dict(self)if not _IS_SHUTDOWN else {},\n  )\n  \n  \ndef _get_handle(dll,dotnet_root:StrOrPath,runtime_config:StrOrPath):\n params=ffi.new(\"hostfxr_initialize_parameters*\")\n params.size=ffi.sizeof(\"hostfxr_initialize_parameters\")\n \n params.host_path=ffi.NULL\n dotnet_root_p=ffi.new(\"char_t[]\",encode(str(Path(dotnet_root))))\n params.dotnet_root=dotnet_root_p\n \n handle_ptr=ffi.new(\"hostfxr_handle*\")\n \n res=dll.hostfxr_initialize_for_runtime_config(\n encode(str(Path(runtime_config))),params,handle_ptr\n )\n check_result(res)\n \n return handle_ptr[0]\n \n \ndef _get_load_func(dll,handle):\n delegate_ptr=ffi.new(\"void**\")\n \n res=dll.hostfxr_get_runtime_delegate(\n handle,dll.hdt_load_assembly_and_get_function_pointer,delegate_ptr\n )\n check_result(res)\n \n return ffi.cast(\"load_assembly_and_get_function_pointer_fn\",delegate_ptr[0])\n \n \nif sys.platform ==\"win32\":\n\n def encode(string:str):\n  return string\n  \n def decode(char_ptr)->str:\n  return ffi.string(char_ptr)\n  \nelse :\n\n def encode(string:str):\n  return string.encode(\"utf8\")\n  \n def decode(char_ptr)->str:\n  return ffi.string(char_ptr).decode(\"utf8\")\n", ["clr_loader.ffi", "clr_loader.types", "clr_loader.util", "pathlib", "sys", "typing"]], "clr_loader.mono": [".py", "import atexit\nimport re\nfrom pathlib import Path\nfrom typing import Any,Dict,Optional,Sequence\n\nfrom .ffi import ffi,load_mono\nfrom .types import Runtime,RuntimeInfo\nfrom .util import optional_path_as_string,path_as_string\n\n__all__=[\"Mono\"]\n\n\n_MONO:Any=None\n_ROOT_DOMAIN:Any=None\n\n\nclass Mono(Runtime):\n def __init__(\n self,\n libmono:Optional[Path],\n *,\n domain:Optional[str]=None ,\n debug:bool=False ,\n jit_options:Optional[Sequence[str]]=None ,\n config_file:Optional[Path]=None ,\n global_config_file:Optional[Path]=None ,\n assembly_dir:Optional[str]=None ,\n config_dir:Optional[str]=None ,\n set_signal_chaining:bool=False ,\n ):\n  self._assemblies:Dict[Path,Any]={}\n  \n  self._version=initialize(\n  config_file=optional_path_as_string(config_file),\n  debug=debug,\n  jit_options=jit_options,\n  global_config_file=optional_path_as_string(global_config_file),\n  libmono=libmono,\n  assembly_dir=assembly_dir,\n  config_dir=config_dir,\n  set_signal_chaining=set_signal_chaining,\n  )\n  \n  if domain is None :\n   self._domain=_ROOT_DOMAIN\n  else :\n   raise NotImplementedError\n   \n def _get_callable(self,assembly_path,typename,function):\n  assembly_path=Path(assembly_path)\n  assembly=self._assemblies.get(assembly_path)\n  if not assembly:\n   assembly=_MONO.mono_domain_assembly_open(\n   self._domain,path_as_string(assembly_path).encode(\"utf8\")\n   )\n   _check_result(assembly,f\"Unable to load assembly {assembly_path}\")\n   self._assemblies[assembly_path]=assembly\n   \n  image=_MONO.mono_assembly_get_image(assembly)\n  _check_result(image,\"Unable to load image from assembly\")\n  \n  desc=MethodDesc(typename,function)\n  method=desc.search(image)\n  _check_result(\n  method,f\"Could not find method {typename}.{function} in assembly\"\n  )\n  \n  return MonoMethod(method)\n  \n def info(self)->RuntimeInfo:\n  return RuntimeInfo(\n  kind=\"Mono\",\n  version=self._version,\n  initialized=True ,\n  shutdown=_MONO is None ,\n  properties={},\n  )\n  \n def shutdown(self)->None :\n \n \n  pass\n  \n  \nclass MethodDesc:\n def __init__(self,typename,function):\n  self._desc=f\"{typename}:{function}\"\n  self._ptr=_MONO.mono_method_desc_new(\n  self._desc.encode(\"utf8\"),1\n  )\n  \n def search(self,image):\n  return _MONO.mono_method_desc_search_in_image(self._ptr,image)\n  \n def __del__(self):\n  if _MONO:\n   _MONO.mono_method_desc_free(self._ptr)\n   \n   \nclass MonoMethod:\n def __init__(self,ptr):\n  self._ptr=ptr\n  \n def __call__(self,ptr,size):\n  exception=ffi.new(\"MonoObject**\")\n  params=ffi.new(\"void*[2]\")\n  \n  \n  ptr_ptr=ffi.new(\"void**\",ptr)\n  size_ptr=ffi.new(\"int32_t*\",size)\n  \n  params[0]=ptr_ptr\n  params[1]=size_ptr\n  \n  res=_MONO.mono_runtime_invoke(self._ptr,ffi.NULL,params,exception)\n  _check_result(res,\"Failed to call method\")\n  \n  unboxed=ffi.cast(\"int32_t*\",_MONO.mono_object_unbox(res))\n  _check_result(unboxed,\"Failed to convert result to int\")\n  \n  return unboxed[0]\n  \n  \ndef initialize(\nlibmono:Optional[Path],\ndebug:bool=False ,\njit_options:Optional[Sequence[str]]=None ,\nconfig_file:Optional[str]=None ,\nglobal_config_file:Optional[str]=None ,\nassembly_dir:Optional[str]=None ,\nconfig_dir:Optional[str]=None ,\nset_signal_chaining:bool=False ,\n)->str:\n global _MONO,_ROOT_DOMAIN\n if _MONO is None :\n  _MONO=load_mono(libmono)\n  \n  if assembly_dir is not None and config_dir is not None :\n   _MONO.mono_set_dirs(assembly_dir,config_dir)\n   \n   \n  global_encoded=global_config_file or ffi.NULL\n  _MONO.mono_config_parse(global_encoded)\n  \n  \n  \n  if config_file is None :\n   config_file=\"\"\n   \n  config_encoded=config_file.encode(\"utf8\")\n  \n  if jit_options:\n   options=[ffi.new(\"char[]\",o.encode(\"utf8\"))for o in jit_options]\n   _MONO.mono_jit_parse_options(len(options),options)\n  else :\n   options=[]\n   \n  if set_signal_chaining:\n   _MONO.mono_set_signal_chaining(True )\n   \n  if debug:\n   _MONO.mono_debug_init(_MONO.MONO_DEBUG_FORMAT_MONO)\n   \n  _ROOT_DOMAIN=_MONO.mono_jit_init(b\"clr_loader\")\n  _MONO.mono_domain_set_config(_ROOT_DOMAIN,b\".\",config_encoded)\n  _check_result(_ROOT_DOMAIN,\"Failed to initialize Mono\")\n  \n build=_MONO.mono_get_runtime_build_info()\n _check_result(build,\"Failed to get Mono version\")\n ver_str=ffi.string(build).decode(\"utf8\")\n \n ver=re.match(r\"^(?P<major>\\d+)\\.(?P<minor>\\d+)\\.[\\d.]+\",ver_str)\n if ver is not None :\n  major=int(ver.group(\"major\"))\n  minor=int(ver.group(\"minor\"))\n  \n  if major <6 or (major ==6 and minor <12):\n   import warnings\n   \n   warnings.warn(\n   \"Hosting Mono versions before v6.12 is known to be problematic. \"\n   \"If the process crashes shortly after you see this message, try \"\n   \"updating Mono to at least v6.12.\"\n   )\n   \n atexit.register(_release)\n return ver_str\n \n \ndef _release()->None :\n global _MONO,_ROOT_DOMAIN\n if _ROOT_DOMAIN is not None and _MONO is not None :\n  _MONO.mono_jit_cleanup(_ROOT_DOMAIN)\n  _MONO=None\n  _ROOT_DOMAIN=None\n  \n  \ndef _check_result(res:Any,msg:str)->None :\n if res ==ffi.NULL or not res:\n  raise RuntimeError(msg)\n", ["atexit", "clr_loader.ffi", "clr_loader.types", "clr_loader.util", "pathlib", "re", "typing", "warnings"]], "clr_loader.netfx": [".py", "import atexit\nfrom pathlib import Path\nfrom typing import Any,Optional\n\nfrom .ffi import ffi,load_netfx\nfrom .types import Runtime,RuntimeInfo,StrOrPath\n\n_FW:Any=None\n\n\nclass NetFx(Runtime):\n def __init__(\n self,domain:Optional[str]=None ,config_file:Optional[Path]=None\n ):\n  initialize()\n  if config_file is not None :\n   config_file_s=str(config_file)\n  else :\n   config_file_s=ffi.NULL\n   \n  self._domain_name=domain\n  self._config_file=config_file\n  self._domain=_FW.pyclr_create_appdomain(domain or ffi.NULL,config_file_s)\n  \n def info(self)->RuntimeInfo:\n  return RuntimeInfo(\n  kind=\".NET Framework\",\n  version=\"<undefined>\",\n  initialized=True ,\n  shutdown=_FW is None ,\n  properties=dict(\n  domain=self._domain_name or \"\",config_file=str(self._config_file)\n  ),\n  )\n  \n def _get_callable(self,assembly_path:StrOrPath,typename:str,function:str):\n  func=_FW.pyclr_get_function(\n  self._domain,\n  str(Path(assembly_path)).encode(\"utf8\"),\n  typename.encode(\"utf8\"),\n  function.encode(\"utf8\"),\n  )\n  \n  return func\n  \n def shutdown(self):\n  if self._domain and _FW:\n   _FW.pyclr_close_appdomain(self._domain)\n   \n   \ndef initialize():\n global _FW\n if _FW is not None :\n  return\n  \n _FW=load_netfx()\n _FW.pyclr_initialize()\n \n atexit.register(_release)\n \n \ndef _release():\n global _FW\n if _FW is not None :\n  _FW.pyclr_finalize()\n  _FW=None\n", ["atexit", "clr_loader.ffi", "clr_loader.types", "pathlib", "typing"]], "clr_loader.types": [".py", "from abc import ABCMeta,abstractmethod\nfrom dataclasses import dataclass,field\nfrom os import PathLike\nfrom typing import Any,Callable,Dict,Optional,Union\n\n__all__=[\"StrOrPath\"]\n\nStrOrPath=Union[str,PathLike]\n\n\n@dataclass\nclass RuntimeInfo:\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n kind:str\n version:str\n initialized:bool\n shutdown:bool\n properties:Dict[str,str]=field(repr=False )\n \n def __str__(self)->str:\n  return (\n  f\"Runtime: {self.kind}\\n\"\n  \"=============\\n\"\n  f\"  Version:      {self.version}\\n\"\n  f\"  Initialized:  {self.initialized}\\n\"\n  f\"  Shut down:    {self.shutdown}\\n\"\n  f\"  Properties:\\n\"\n  +\"\\n\".join(\n  f\"    {key} = {_truncate(value, 65 - len(key))}\"\n  for key,value in self.properties.items()\n  )\n  )\n  \n  \nclass ClrFunction:\n def __init__(\n self,runtime:\"Runtime\",assembly:StrOrPath,typename:str,func_name:str\n ):\n  self._assembly=assembly\n  self._class=typename\n  self._name=func_name\n  \n  self._callable=runtime._get_callable(assembly,typename,func_name)\n  \n def __call__(self,buffer:bytes)->int:\n  from .ffi import ffi\n  \n  buf_arr=ffi.from_buffer(\"char[]\",buffer)\n  return self._callable(ffi.cast(\"void*\",buf_arr),len(buf_arr))\n  \n def __repr__(self)->str:\n  return f\"<ClrFunction {self._class}.{self._name} in {self._assembly}>\"\n  \n  \nclass Assembly:\n def __init__(self,runtime:\"Runtime\",path:StrOrPath):\n  self._runtime=runtime\n  self._path=path\n  \n def get_function(self,name:str,func:Optional[str]=None )->ClrFunction:\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  if func is None :\n   name,func=name.rsplit(\".\",1)\n   \n  return ClrFunction(self._runtime,self._path,name,func)\n  \n def __repr__(self)->str:\n  return f\"<Assembly {self._path} in {self._runtime}>\"\n  \n  \nclass Runtime(metaclass=ABCMeta):\n ''\n\n\n\n \n \n @abstractmethod\n def info(self)->RuntimeInfo:\n  ''\n  pass\n  \n def get_assembly(self,assembly_path:StrOrPath)->Assembly:\n  ''\n\n\n\n\n  \n  return Assembly(self,assembly_path)\n  \n @abstractmethod\n def _get_callable(\n self,assembly_path:StrOrPath,typename:str,function:str\n )->Callable[[Any,int],Any]:\n  ''\n  pass\n  \n @abstractmethod\n def shutdown(self)->None :\n  ''\n\n\n  \n  pass\n  \n def __del__(self)->None :\n  self.shutdown()\n  \n  \ndef _truncate(string:str,length:int)->str:\n if length <=1:\n  raise TypeError(\"length must be > 1\")\n if len(string)>length -1:\n  return f\"{string[:length-1]}\u2026\"\n else :\n  return string\n", ["abc", "clr_loader.ffi", "dataclasses", "os", "typing"]], "clr_loader": [".py", "from pathlib import Path\nfrom tempfile import TemporaryDirectory\nfrom typing import Dict,Optional,Sequence\n\nfrom .types import Assembly,Runtime,RuntimeInfo\nfrom .util import StrOrPath\nfrom .util.find import find_dotnet_root,find_libmono,find_runtimes\nfrom .util.runtime_spec import DotnetCoreRuntimeSpec\n\n__all__=[\n\"get_mono\",\n\"get_netfx\",\n\"get_coreclr\",\n\"find_dotnet_root\",\n\"find_libmono\",\n\"find_runtimes\",\n\"Runtime\",\n\"Assembly\",\n\"RuntimeInfo\",\n\"DotnetCoreRuntimeSpec\",\n]\n\n\ndef get_mono(\n*,\n\nconfig_file:Optional[StrOrPath]=None ,\nglobal_config_file:Optional[StrOrPath]=None ,\nlibmono:Optional[StrOrPath]=None ,\nsgen:bool=True ,\ndebug:bool=False ,\njit_options:Optional[Sequence[str]]=None ,\nassembly_dir:Optional[str]=None ,\nconfig_dir:Optional[str]=None ,\nset_signal_chaining:bool=False\n)->Runtime:\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n from .mono import Mono\n \n libmono=_maybe_path(libmono)\n if libmono is None :\n  libmono=find_libmono(sgen=sgen)\n  \n impl=Mono(\n \n debug=debug,\n jit_options=jit_options,\n config_file=_maybe_path(config_file),\n global_config_file=_maybe_path(global_config_file),\n libmono=libmono,\n assembly_dir=assembly_dir,\n config_dir=config_dir,\n set_signal_chaining=set_signal_chaining,\n )\n return impl\n \n \ndef get_coreclr(\n*,\nruntime_config:Optional[StrOrPath]=None ,\ndotnet_root:Optional[StrOrPath]=None ,\nproperties:Optional[Dict[str,str]]=None ,\nruntime_spec:Optional[DotnetCoreRuntimeSpec]=None ,\n)->Runtime:\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n from .hostfxr import DotnetCoreRuntime\n \n dotnet_root=_maybe_path(dotnet_root)\n if dotnet_root is None :\n  dotnet_root=find_dotnet_root()\n  \n temp_dir=None\n runtime_config=_maybe_path(runtime_config)\n if runtime_config is None :\n  if runtime_spec is None :\n   candidates=[\n   rt for rt in find_runtimes()if rt.name ==\"Microsoft.NETCore.App\"\n   ]\n   candidates.sort(key=lambda spec:spec.version,reverse=True )\n   if not candidates:\n    raise RuntimeError(\"Failed to find a suitable runtime\")\n    \n   runtime_spec=candidates[0]\n   \n  temp_dir=TemporaryDirectory()\n  runtime_config=Path(temp_dir.name)/\"runtimeconfig.json\"\n  \n  with open(runtime_config,\"w\")as f:\n   runtime_spec.write_config(f)\n   \n impl=DotnetCoreRuntime(runtime_config=runtime_config,dotnet_root=dotnet_root)\n if properties:\n  for key,value in properties.items():\n   impl[key]=value\n   \n if temp_dir:\n  temp_dir.cleanup()\n  \n return impl\n \n \ndef get_netfx(\n*,domain:Optional[str]=None ,config_file:Optional[StrOrPath]=None\n)->Runtime:\n ''\n\n\n\n\n\n\n\n\n \n from .netfx import NetFx\n \n impl=NetFx(domain=domain,config_file=_maybe_path(config_file))\n return impl\n \n \ndef _maybe_path(p:Optional[StrOrPath])->Optional[Path]:\n if p is None :\n  return None\n else :\n  return Path(p)\n", ["clr_loader.hostfxr", "clr_loader.mono", "clr_loader.netfx", "clr_loader.types", "clr_loader.util", "clr_loader.util.find", "clr_loader.util.runtime_spec", "pathlib", "tempfile", "typing"], 1], "clr_loader.ffi.hostfxr": [".py", "\n\nimport sys\n\n\ncdef=[]\n\nif sys.platform ==\"win32\":\n cdef.append(\"typedef wchar_t char_t;\")\nelse :\n cdef.append(\"typedef char char_t;\")\n \n \ncdef.append(\n\"\"\"\nenum hostfxr_delegate_type\n{\n    hdt_com_activation,\n    hdt_load_in_memory_assembly,\n    hdt_winrt_activation,\n    hdt_com_register,\n    hdt_com_unregister,\n    hdt_load_assembly_and_get_function_pointer\n};\n\nint32_t hostfxr_main(const int argc, const char_t **argv);\n\nint32_t hostfxr_main_startupinfo(\n    const int argc,\n    const char_t **argv,\n    const char_t *host_path,\n    const char_t *dotnet_root,\n    const char_t *app_path);\n\ntypedef void (*hostfxr_error_writer_fn)(const char_t *message);\nhostfxr_error_writer_fn hostfxr_set_error_writer(hostfxr_error_writer_fn error_writer);\n\ntypedef void* hostfxr_handle;\ntypedef struct hostfxr_initialize_parameters\n{\n    size_t size;\n    const char_t *host_path;\n    const char_t *dotnet_root;\n} hostfxr_initialize_parameters;\n\nint32_t hostfxr_initialize_for_dotnet_command_line(\n    int argc,\n    const char_t **argv,\n    const hostfxr_initialize_parameters *parameters,\n    /*out*/ hostfxr_handle *host_context_handle);\nint32_t hostfxr_initialize_for_runtime_config(\n    const char_t *runtime_config_path,\n    const hostfxr_initialize_parameters *parameters,\n    /*out*/ hostfxr_handle *host_context_handle);\n\nint32_t hostfxr_get_runtime_property_value(\n    const hostfxr_handle host_context_handle,\n    const char_t *name,\n    /*out*/ const char_t **value);\nint32_t hostfxr_set_runtime_property_value(\n    const hostfxr_handle host_context_handle,\n    const char_t *name,\n    const char_t *value);\nint32_t hostfxr_get_runtime_properties(\n    const hostfxr_handle host_context_handle,\n    /*inout*/ size_t * count,\n    /*out*/ const char_t **keys,\n    /*out*/ const char_t **values);\n\nint32_t hostfxr_run_app(const hostfxr_handle host_context_handle);\nint32_t hostfxr_get_runtime_delegate(\n    const hostfxr_handle host_context_handle,\n    enum hostfxr_delegate_type type,\n    /*out*/ void **delegate);\n\nint32_t hostfxr_close(const hostfxr_handle host_context_handle);\n\"\"\"\n)\n\n\ncdef.append(\n\"\"\"\n// Signature of delegate returned by coreclr_delegate_type::load_assembly_and_get_function_pointer\ntypedef int (__stdcall *load_assembly_and_get_function_pointer_fn)(\n    const char_t *assembly_path      /* Fully qualified path to assembly */,\n    const char_t *type_name          /* Assembly qualified type name */,\n    const char_t *method_name        /* Public static method name compatible with delegateType */,\n    const char_t *delegate_type_name /* Assembly qualified delegate type name or null */,\n    void         *reserved           /* Extensibility parameter (currently unused and must be 0) */,\n    /*out*/ void **delegate          /* Pointer where to store the function pointer result */);\n\n// Signature of delegate returned by load_assembly_and_get_function_pointer_fn when delegate_type_name == null (default)\ntypedef int (__stdcall *component_entry_point_fn)(void *arg, int32_t arg_size_in_bytes);\n\"\"\"\n)\n", ["sys"]], "clr_loader.ffi.mono": [".py", "\n\ncdef=[]\n\ncdef.append(\n\"\"\"\ntypedef struct _MonoDomain MonoDomain;\ntypedef struct _MonoAssembly MonoAssembly;\ntypedef struct _MonoImage MonoImage;\ntypedef struct _MonoMethodDesc MonoMethodDesc;\ntypedef struct _MonoMethod MonoMethod;\ntypedef struct _MonoObject MonoObject;\n\ntypedef enum {\n\tMONO_DEBUG_FORMAT_NONE,\n\tMONO_DEBUG_FORMAT_MONO,\n\t/* Deprecated, the mdb debugger is not longer supported. */\n\tMONO_DEBUG_FORMAT_DEBUGGER\n} MonoDebugFormat;\n\nchar* mono_get_runtime_build_info (void);\n\nMonoDomain* mono_jit_init(const char *root_domain_name);\nvoid mono_jit_cleanup(MonoDomain *domain);\nvoid mono_jit_parse_options(int argc, char * argv[]);\n\nvoid mono_debug_init (MonoDebugFormat format);\n\nMonoAssembly* mono_domain_assembly_open(MonoDomain *domain, const char *name);\nMonoImage* mono_assembly_get_image(MonoAssembly *assembly);\n\nvoid mono_domain_set_config(MonoDomain *domain, const char *base_dir, const char *config_file_name);\nvoid mono_config_parse(const char* path);\n\nMonoMethodDesc* mono_method_desc_new(const char* name, bool include_namespace);\nMonoMethod* mono_method_desc_search_in_image(MonoMethodDesc *method_desc, MonoImage *image);\nvoid mono_method_desc_free(MonoMethodDesc *method_desc);\n\nMonoObject* mono_runtime_invoke(MonoMethod *method, void *obj, void **params, MonoObject **exc);\n\nvoid* mono_object_unbox(MonoObject *object);\n\nvoid mono_set_dirs(const char *assembly_dir, const char* config_dir);\n\nvoid mono_set_signal_chaining(bool chain_signals);\n\n\"\"\"\n)\n", []], "clr_loader.ffi.netfx": [".py", "\n\ncdef=[\n\"\"\"\ntypedef void* pyclr_domain;\ntypedef int (*entry_point)(void* buffer, int size);\n\nvoid pyclr_initialize();\nvoid* pyclr_create_appdomain(const char* name, const char* config_file);\nentry_point pyclr_get_function(pyclr_domain domain, const char* assembly_path, const char* class_name, const char* function);\nvoid pyclr_close_appdomain(pyclr_domain domain);\nvoid pyclr_finalize();\n    \"\"\"\n]\n", []], "clr_loader.ffi": [".py", "import sys\nfrom pathlib import Path\nfrom typing import Optional,Tuple\n\nimport cffi\n\nfrom . import hostfxr,mono,netfx\n\n__all__=[\"ffi\",\"load_hostfxr\",\"load_mono\",\"load_netfx\"]\n\nffi=cffi.FFI()\n\nfor cdef in hostfxr.cdef+mono.cdef+netfx.cdef:\n ffi.cdef(cdef)\n \n \ndef load_hostfxr(dotnet_root:Path):\n hostfxr_name=_get_dll_name(\"hostfxr\")\n dotnet_root=dotnet_root.absolute()\n \n \n \n hostfxr_path=dotnet_root /\"host\"/\"fxr\"\n hostfxr_paths=hostfxr_path.glob(f\"?.*/{hostfxr_name}\")\n \n for hostfxr_path in reversed(sorted(hostfxr_paths,key=_path_to_version)):\n  try :\n   return ffi.dlopen(str(hostfxr_path))\n  except Exception:\n   pass\n   \n try :\n  return ffi.dlopen(str(dotnet_root /hostfxr_name))\n except Exception:\n  pass\n  \n raise RuntimeError(f\"Could not find a suitable hostfxr library in {dotnet_root}\")\n \n \ndef load_mono(path:Optional[Path]=None ):\n\n if sys.platform ==\"linux\":\n  ffi.dlopen(\"stdc++\",ffi.RTLD_GLOBAL)\n  \n path_str=str(path)if path else None\n return ffi.dlopen(path_str,ffi.RTLD_GLOBAL)\n \n \ndef load_netfx():\n if sys.platform !=\"win32\":\n  raise RuntimeError(\".NET Framework is only supported on Windows\")\n  \n dirname=Path(__file__).parent /\"dlls\"\n if sys.maxsize >2 **32:\n  arch=\"amd64\"\n else :\n  arch=\"x86\"\n  \n path=dirname /arch /\"ClrLoader.dll\"\n \n return ffi.dlopen(str(path))\n \n \ndef _path_to_version(path:Path)->Tuple[int,int,int]:\n name=path.parent.name\n try :\n  res=list(map(int,name.split(\".\")))\n  return tuple(res+[0,0,0])[:3]\n except Exception:\n  return (0,0,0)\n  \n  \ndef _get_dll_name(name:str)->str:\n if sys.platform ==\"win32\":\n  return f\"{name}.dll\"\n elif sys.platform ==\"darwin\":\n  return f\"lib{name}.dylib\"\n else :\n  return f\"lib{name}.so\"\n", ["cffi", "clr_loader.ffi", "pathlib", "sys", "typing"], 1], "clr_loader.util.clr_error": [".py", "from typing import Optional\n\n\nclass ClrError(Exception):\n def __init__(\n self,\n hresult:int,\n name:Optional[str]=None ,\n message:Optional[str]=None ,\n comment:Optional[str]=None ,\n ):\n  self.hresult=hresult\n  self.name=name\n  self.message=message\n  self.comment=comment\n  super().__init__(self.message)\n  \n def __str__(self):\n  if self.message:\n   return f\"{hex(self.hresult)}: {self.name} => {self.message}\"\n  elif self.name:\n   return f\"{hex(self.hresult)}: {self.name}\"\n  else :\n   return f\"{hex(self.hresult)}\"\n   \n def __repr__(self):\n  return f\"<ClrError {str(self)}>\"\n", ["typing"]], "clr_loader.util.coreclr_errors": [".py", "from typing import Dict,Optional\n\nfrom .clr_error import ClrError\n\n\ndef get_coreclr_error(hresult:int)->Optional[ClrError]:\n name=SymbolicName.get(hresult)\n if not name:\n  return None\n  \n return ClrError(\n hresult=hresult,\n name=name,\n message=Message.get(hresult),\n comment=Comment.get(hresult),\n )\n \n \nComment:Dict[int,str]={}\nSymbolicName:Dict[int,str]={}\nMessage:Dict[int,str]={}\n\n\nif __name__ ==\"__main__\":\n from sys import argv,exit\n from xml.etree import ElementTree\n \n if len(argv)<2:\n  url=\"https://raw.githubusercontent.com/dotnet/coreclr/master/src/inc/corerror.xml\"\n  print(\n  f\"Please download corerror.xml from {url} and pass as an argument to this script\"\n  )\n  exit(1)\n  \n tree=ElementTree.parse(argv[1])\n \n print(f\"Parsed {argv[1]}, updating {__file__}...\")\n \n marker=\"# == Autogenerated from corerror.xml ==\"\n \n with open(__file__,\"r\")as f:\n  current=f.read()\n  before,_,_=current.rpartition(marker)\n  \n self=open(__file__,\"w\")\n self.seek(0)\n self.write(before)\n self.write(marker)\n self.write(\"\\n\\n\")\n \n for row in tree.findall(\".//HRESULT\"):\n  try :\n   numeric_value=int(row.attrib[\"NumericValue\"],base=16)\n   \n   for child in row:\n    if child.text:\n     text=child.text.strip(' \"')\n     self.write(f\"{child.tag}[{hex(numeric_value)}] = {repr(text)}\\n\")\n  except ValueError:\n   print(\"Failed to process numeric value:\",numeric_value)\n   \n self.close()\n \n \n \n \n \nSymbolicName[0x131106]='CLDB_S_TRUNCATION'\nComment[0x131106]='STATUS: Data value was truncated.'\nSymbolicName[0x131197]='META_S_DUPLICATE'\nComment[0x131197]='Attempt to define an object that already exists in valid scenerios.'\nSymbolicName[0x13130b]='CORDBG_S_BAD_START_SEQUENCE_POINT'\nComment[0x13130b]='Attempt to SetIP not at a sequence point sequence point.'\nSymbolicName[0x13130c]='CORDBG_S_BAD_END_SEQUENCE_POINT'\nComment[0x13130c]='Attempt to SetIP when not going to a sequence point. If both this and CORDBG_E_BAD_START_SEQUENCE_POINT are true, only CORDBG_E_BAD_START_SEQUENCE_POINT will be reported.'\nSymbolicName[0x131316]='CORDBG_S_FUNC_EVAL_HAS_NO_RESULT'\nComment[0x131316]='Some Func evals will lack a return value,'\nSymbolicName[0x131317]='CORDBG_S_VALUE_POINTS_TO_VOID'\nComment[0x131317]=\"The Debugging API doesn't support dereferencing void pointers.\"\nSymbolicName[0x131319]='CORDBG_S_FUNC_EVAL_ABORTED'\nComment[0x131319]='The func eval completed, but was aborted.'\nSymbolicName[0x131324]='CORDBG_S_AT_END_OF_STACK'\nMessage[0x131324]='The stack walk has reached the end of the stack.  There are no more frames to walk.'\nComment[0x131324]='The stack walk has reached the end of the stack.  There are no more frames to walk.'\nSymbolicName[0x131c13]='CORDBG_S_NOT_ALL_BITS_SET'\nComment[0x131c13]='Not all bits specified were successfully applied'\nSymbolicName[0x80131001]='CEE_E_CVTRES_NOT_FOUND'\nMessage[0x80131001]='cvtres.exe not found.'\nComment[0x80131001]='cannot find cvtres.exe'\nSymbolicName[0x80131013]='COR_E_TYPEUNLOADED'\nMessage[0x80131013]='Type has been unloaded.'\nComment[0x80131013]='The type had been unloaded.'\nSymbolicName[0x80131014]='COR_E_APPDOMAINUNLOADED'\nMessage[0x80131014]='Attempted to access an unloaded appdomain.'\nComment[0x80131014]='access unloaded appdomain'\nSymbolicName[0x80131015]='COR_E_CANNOTUNLOADAPPDOMAIN'\nMessage[0x80131015]='Error while unloading appdomain.'\nComment[0x80131015]='Error while unloading an appdomain'\nSymbolicName[0x80131016]='MSEE_E_ASSEMBLYLOADINPROGRESS'\nMessage[0x80131016]='Assembly is still being loaded.'\nComment[0x80131016]='Assembly is being currently being loaded'\nSymbolicName[0x80131018]='COR_E_ASSEMBLYEXPECTED'\nMessage[0x80131018]='The module was expected to contain an assembly manifest.'\nComment[0x80131018]='The module was expected to contain an assembly manifest.'\nSymbolicName[0x80131019]='COR_E_FIXUPSINEXE'\nMessage[0x80131019]='Attempt to load an unverifiable executable with fixups (IAT with more than 2 sections or a TLS section.)'\nComment[0x80131019]='Attempt to load an unverifiable exe with fixups (IAT with more than 2 sections or a TLS section)'\nSymbolicName[0x8013101b]='COR_E_NEWER_RUNTIME'\nMessage[0x8013101b]='This assembly is built by a runtime newer than the currently loaded runtime and cannot be loaded.'\nComment[0x8013101b]='The assembly is built by a runtime newer than the currently loaded runtime, and cannot be loaded.'\nSymbolicName[0x8013101e]='COR_E_MULTIMODULEASSEMBLIESDIALLOWED'\nMessage[0x8013101e]='The module cannot be loaded because only single file assemblies are supported.'\nComment[0x8013101e]='The module cannot be loaded because only single file assemblies are supported.'\nSymbolicName[0x80131020]='HOST_E_DEADLOCK'\nMessage[0x80131020]='Host detected a deadlock on a blocking operation.'\nComment[0x80131020]='Host detects deadlock on a blocking operation'\nSymbolicName[0x80131022]='HOST_E_INVALIDOPERATION'\nMessage[0x80131022]='Invalid operation.'\nComment[0x80131022]='The operation is invalid'\nSymbolicName[0x80131023]='HOST_E_CLRNOTAVAILABLE'\nMessage[0x80131023]='CLR has been disabled due to unrecoverable error.'\nComment[0x80131023]='CLR has been disabled due to unrecoverable error'\nSymbolicName[0x80131027]='HOST_E_EXITPROCESS_THREADABORT'\nMessage[0x80131027]='Process exited due to ThreadAbort escalation.'\nComment[0x80131027]='ExitProcess due to ThreadAbort escalation'\nSymbolicName[0x80131028]='HOST_E_EXITPROCESS_ADUNLOAD'\nMessage[0x80131028]='Process exited due to AD Unload escalation.'\nComment[0x80131028]='ExitProcess due to AD Unload escalation'\nSymbolicName[0x80131029]='HOST_E_EXITPROCESS_TIMEOUT'\nMessage[0x80131029]='Process exited due to Timeout escalation.'\nComment[0x80131029]='ExitProcess due to Timeout escalation'\nSymbolicName[0x8013102a]='HOST_E_EXITPROCESS_OUTOFMEMORY'\nMessage[0x8013102a]='Process exited due to OutOfMemory escalation.'\nComment[0x8013102a]='ExitProcess due to OutOfMemory escalation'\nSymbolicName[0x80131039]='COR_E_MODULE_HASH_CHECK_FAILED'\nMessage[0x80131039]=\"The check of the module's hash failed.\"\nComment[0x80131039]=\"The check of the module's hash failed.\"\nSymbolicName[0x80131040]='FUSION_E_REF_DEF_MISMATCH'\nMessage[0x80131040]=\"The located assembly's manifest definition does not match the assembly reference.\"\nComment[0x80131040]=\"The located assembly's manifest definition does not match the assembly reference.\"\nSymbolicName[0x80131041]='FUSION_E_INVALID_PRIVATE_ASM_LOCATION'\nMessage[0x80131041]='The private assembly was located outside the appbase directory.'\nComment[0x80131041]='The private assembly was located outside the appbase directory.'\nSymbolicName[0x80131042]='FUSION_E_ASM_MODULE_MISSING'\nMessage[0x80131042]='A module specified in the manifest was not found.'\nComment[0x80131042]='A module specified in the manifest was not found.'\nSymbolicName[0x80131044]='FUSION_E_PRIVATE_ASM_DISALLOWED'\nMessage[0x80131044]='A strongly-named assembly is required.'\nComment[0x80131044]='A strongly-named assembly is required.'\nSymbolicName[0x80131045]='FUSION_E_SIGNATURE_CHECK_FAILED'\nMessage[0x80131045]='Strong name signature could not be verified.  The assembly may have been tampered with, or it was delay signed but not fully signed with the correct private key.'\nComment[0x80131045]='The check of the signature failed.'\nSymbolicName[0x80131047]='FUSION_E_INVALID_NAME'\nMessage[0x80131047]='The given assembly name or codebase was invalid.'\nComment[0x80131047]='The given assembly name or codebase was invalid.'\nSymbolicName[0x80131048]='FUSION_E_CODE_DOWNLOAD_DISABLED'\nMessage[0x80131048]='HTTP download of assemblies has been disabled for this appdomain.'\nComment[0x80131048]='HTTP download of assemblies has been disabled for this appdomain.'\nSymbolicName[0x80131050]='FUSION_E_HOST_GAC_ASM_MISMATCH'\nMessage[0x80131050]='Assembly in host store has a different signature than assembly in GAC.'\nComment[0x80131050]='Assembly in host store has a different signature than assembly in GAC'\nSymbolicName[0x80131051]='FUSION_E_LOADFROM_BLOCKED'\nMessage[0x80131051]='LoadFrom(), LoadFile(), Load(byte[]) and LoadModule() have been disabled by the host.'\nComment[0x80131051]=\"Hosted environment doesn't permit loading by location\"\nSymbolicName[0x80131052]='FUSION_E_CACHEFILE_FAILED'\nMessage[0x80131052]='Failed to add file to AppDomain cache.'\nComment[0x80131052]='Failed to add file to AppDomain cache'\nSymbolicName[0x80131053]='FUSION_E_APP_DOMAIN_LOCKED'\nMessage[0x80131053]='The requested assembly version conflicts with what is already bound in the app domain or specified in the manifest.'\nComment[0x80131053]='The requested assembly version conflicts with what is already bound in the app domain or specified in the manifest'\nSymbolicName[0x80131054]='FUSION_E_CONFIGURATION_ERROR'\nMessage[0x80131054]=\"The requested assembly name was neither found in the GAC nor in the manifest or the manifest's specified location is wrong.\"\nComment[0x80131054]=\"The requested assembly name was neither found in the GAC nor in the manifest or the manifest's specified location is wrong\"\nSymbolicName[0x80131055]='FUSION_E_MANIFEST_PARSE_ERROR'\nMessage[0x80131055]='Unexpected error while parsing the specified manifest.'\nComment[0x80131055]='Unexpected error while parsing the specified manifest'\nSymbolicName[0x80131058]='COR_E_LOADING_REFERENCE_ASSEMBLY'\nMessage[0x80131058]='Reference assemblies should not be loaded for execution.  They can only be loaded in the Reflection-only loader context.'\nComment[0x80131058]='Reference assemblies should not be loaded for execution.  They can only be loaded in the Reflection-only loader context.'\nSymbolicName[0x80131059]='COR_E_NI_AND_RUNTIME_VERSION_MISMATCH'\nMessage[0x80131059]='The native image could not be loaded, because it was generated for use by a different version of the runtime.'\nComment[0x80131059]='The native image could not be loaded, because it was generated for use by a different version of the runtime.'\nSymbolicName[0x80131069]='COR_E_LOADING_WINMD_REFERENCE_ASSEMBLY'\nMessage[0x80131069]='Contract Windows Runtime assemblies cannot be loaded for execution.  Make sure your application only contains non-contract Windows Runtime assemblies.'\nComment[0x80131069]='Contract Windows Runtime assemblies cannot be loaded for execution.  Make sure your application only contains non-contract Windows Runtime assemblies'\nSymbolicName[0x8013106a]='COR_E_AMBIGUOUSIMPLEMENTATION'\nMessage[0x8013106a]='Ambiguous implementation found.'\nComment[0x8013106a]='Ambiguous implementation found'\nSymbolicName[0x80131100]='CLDB_E_FILE_BADREAD'\nMessage[0x80131100]='Error occurred during a read.'\nComment[0x80131100]='Error occurred during a read.'\nSymbolicName[0x80131101]='CLDB_E_FILE_BADWRITE'\nMessage[0x80131101]='Error occurred during a write.'\nComment[0x80131101]='Error occurred during a write.'\nSymbolicName[0x80131107]='CLDB_E_FILE_OLDVER'\nMessage[0x80131107]='Old version error.'\nComment[0x80131107]='Old version error.'\nSymbolicName[0x8013110a]='CLDB_E_SMDUPLICATE'\nMessage[0x8013110a]='Create of shared memory failed.  A memory mapping of the same name already exists.'\nComment[0x8013110a]='Create of shared memory failed.  A memory mapping of the same name already exists.'\nSymbolicName[0x8013110b]='CLDB_E_NO_DATA'\nMessage[0x8013110b]='No .CLB data in the memory or stream.'\nComment[0x8013110b]=\"There isn't .CLB data in the memory or stream.\"\nSymbolicName[0x8013110d]='CLDB_E_INCOMPATIBLE'\nMessage[0x8013110d]='Importing scope is not compatible with the emitting scope.'\nComment[0x8013110d]='The importing scope is not comptabile with the emitting scope'\nSymbolicName[0x8013110e]='CLDB_E_FILE_CORRUPT'\nMessage[0x8013110e]='File is corrupt.'\nComment[0x8013110e]='File is corrupt.'\nSymbolicName[0x80131110]='CLDB_E_BADUPDATEMODE'\nMessage[0x80131110]='Cannot open a incrementally build scope for full update.'\nComment[0x80131110]='cannot open a incrementally build scope for full update'\nSymbolicName[0x80131124]='CLDB_E_INDEX_NOTFOUND'\nMessage[0x80131124]='Index not found.'\nComment[0x80131124]='Index %s not found.'\nSymbolicName[0x80131130]='CLDB_E_RECORD_NOTFOUND'\nMessage[0x80131130]='Record not found on lookup.'\nComment[0x80131130]=\"Record wasn't found on lookup.\"\nSymbolicName[0x80131135]='CLDB_E_RECORD_OUTOFORDER'\nMessage[0x80131135]='Record is emitted out of order.'\nComment[0x80131135]='Record is emitted out of order.'\nSymbolicName[0x80131154]='CLDB_E_TOO_BIG'\nMessage[0x80131154]='A blob or string was too big.'\nComment[0x80131154]='A blob or string was too big.'\nSymbolicName[0x8013115f]='META_E_INVALID_TOKEN_TYPE'\nMessage[0x8013115f]='A token of the wrong type passed to a metadata function.'\nComment[0x8013115f]='A token of the wrong type passed to a metadata function.'\nSymbolicName[0x80131165]='TLBX_E_LIBNOTREGISTERED'\nMessage[0x80131165]='Typelib export: Type library is not registered.'\nComment[0x80131165]='Typelib export: type library is not registered.'\nSymbolicName[0x8013118a]='META_E_BADMETADATA'\nMessage[0x8013118a]='Merge: Inconsistency in meta data import scope.'\nComment[0x8013118a]='Merge: Inconsistency in meta data import scope'\nSymbolicName[0x80131192]='META_E_BAD_SIGNATURE'\nMessage[0x80131192]='Bad binary signature.'\nComment[0x80131192]='Bad binary signature'\nSymbolicName[0x80131193]='META_E_BAD_INPUT_PARAMETER'\nMessage[0x80131193]='Bad input parameters.'\nComment[0x80131193]='Bad input parameters'\nSymbolicName[0x80131196]='META_E_CANNOTRESOLVETYPEREF'\nMessage[0x80131196]='Cannot resolve typeref.'\nComment[0x80131196]='Cannot resolve typeref'\nSymbolicName[0x80131198]='META_E_STRINGSPACE_FULL'\nMessage[0x80131198]='No logical space left to create more user strings.'\nComment[0x80131198]='No logical space left to create more user strings.'\nSymbolicName[0x8013119a]='META_E_HAS_UNMARKALL'\nMessage[0x8013119a]='Unmark all has been called already.'\nComment[0x8013119a]='Unmark all has been called already'\nSymbolicName[0x8013119b]='META_E_MUST_CALL_UNMARKALL'\nMessage[0x8013119b]='Must call UnmarkAll first before marking.'\nComment[0x8013119b]='Must call UnmarkAll first before marking.'\nSymbolicName[0x801311c0]='META_E_CA_INVALID_TARGET'\nMessage[0x801311c0]='Known custom attribute on invalid target.'\nComment[0x801311c0]='Known custom attribute on invalid target.'\nSymbolicName[0x801311c1]='META_E_CA_INVALID_VALUE'\nMessage[0x801311c1]='Known custom attribute had invalid value.'\nComment[0x801311c1]='Known custom attribute had invalid value.'\nSymbolicName[0x801311c2]='META_E_CA_INVALID_BLOB'\nMessage[0x801311c2]='Known custom attribute blob has bad format.'\nComment[0x801311c2]='Known custom attribute blob is bad format.'\nSymbolicName[0x801311c3]='META_E_CA_REPEATED_ARG'\nMessage[0x801311c3]='Known custom attribute blob has repeated named argument.'\nComment[0x801311c3]='Known custom attribute blob has repeated named argument.'\nSymbolicName[0x801311c4]='META_E_CA_UNKNOWN_ARGUMENT'\nMessage[0x801311c4]='Known custom attribute named argument not recognized.'\nComment[0x801311c4]='Known custom attrubte named arg not recognized.'\nSymbolicName[0x801311c7]='META_E_CA_UNEXPECTED_TYPE'\nMessage[0x801311c7]='Known attribute parser found unexpected type.'\nComment[0x801311c7]='Known attribute parser found unexpected type.'\nSymbolicName[0x801311c8]='META_E_CA_INVALID_ARGTYPE'\nMessage[0x801311c8]='Known attribute parser only handles fields, not properties.'\nComment[0x801311c8]='Known attribute parser only handles fields -- no properties.'\nSymbolicName[0x801311c9]='META_E_CA_INVALID_ARG_FOR_TYPE'\nMessage[0x801311c9]='Known attribute parser found an argument that is invalid for the object it is applied to.'\nComment[0x801311c9]='Known attribute parser found an argument that is invalid for the object it is applied to.'\nSymbolicName[0x801311ca]='META_E_CA_INVALID_UUID'\nMessage[0x801311ca]='The format of the UUID was invalid.'\nComment[0x801311ca]='The format of the UUID was invalid.'\nSymbolicName[0x801311cb]='META_E_CA_INVALID_MARSHALAS_FIELDS'\nMessage[0x801311cb]='The MarshalAs attribute has fields set that are not valid for the specified unmanaged type.'\nComment[0x801311cb]='The MarshalAs attribute has fields set that are not valid for the specified unmanaged type.'\nSymbolicName[0x801311cc]='META_E_CA_NT_FIELDONLY'\nMessage[0x801311cc]='The specified unmanaged type is only valid on fields.'\nComment[0x801311cc]='The specified unmanaged type is only valid on fields.'\nSymbolicName[0x801311cd]='META_E_CA_NEGATIVE_PARAMINDEX'\nMessage[0x801311cd]='The parameter index cannot be negative.'\nComment[0x801311cd]='The parameter index cannot be negative.'\nSymbolicName[0x801311cf]='META_E_CA_NEGATIVE_CONSTSIZE'\nMessage[0x801311cf]='The constant size cannot be negative.'\nComment[0x801311cf]='The constant size cannot be negative.'\nSymbolicName[0x801311d0]='META_E_CA_FIXEDSTR_SIZE_REQUIRED'\nMessage[0x801311d0]='A fixed string requires a size.'\nComment[0x801311d0]='A fixed string requires a size.'\nSymbolicName[0x801311d1]='META_E_CA_CUSTMARSH_TYPE_REQUIRED'\nMessage[0x801311d1]='A custom marshaler requires the custom marshaler type.'\nComment[0x801311d1]='A custom marshaler requires the custom marshaler type.'\nSymbolicName[0x801311d4]='META_E_NOT_IN_ENC_MODE'\nMessage[0x801311d4]='SaveDelta was called without being in EnC mode.'\nComment[0x801311d4]='SaveDelta was called without being in EnC mode'\nSymbolicName[0x801311e5]='META_E_CA_BAD_FRIENDS_ARGS'\nMessage[0x801311e5]=\"InternalsVisibleTo can't have a version, culture, or processor architecture.\"\nComment[0x801311e5]=\"InternalsVisibleTo can't have a version, culture, or processor architecture.\"\nSymbolicName[0x801311e6]='META_E_CA_FRIENDS_SN_REQUIRED'\nComment[0x801311e6]='Strong-name signed assemblies can only grant friend access to strong name-signed assemblies'\nSymbolicName[0x80131203]='VLDTR_E_RID_OUTOFRANGE'\nMessage[0x80131203]='Rid is out of range.'\nComment[0x80131203]='Rid is out of range.'\nSymbolicName[0x80131206]='VLDTR_E_STRING_INVALID'\nMessage[0x80131206]='String offset is invalid.'\nComment[0x80131206]='String offset is invalid.'\nSymbolicName[0x80131207]='VLDTR_E_GUID_INVALID'\nMessage[0x80131207]='GUID offset is invalid.'\nComment[0x80131207]='GUID offset is invalid.'\nSymbolicName[0x80131208]='VLDTR_E_BLOB_INVALID'\nMessage[0x80131208]='Blob offset if invalid.'\nComment[0x80131208]='Blob offset if invalid.'\nSymbolicName[0x80131224]='VLDTR_E_MR_BADCALLINGCONV'\nMessage[0x80131224]='MemberRef has invalid calling convention.'\nComment[0x80131224]='MemberRef has invalid calling convention.'\nSymbolicName[0x80131237]='VLDTR_E_SIGNULL'\nMessage[0x80131237]='Signature specified is zero-sized.'\nComment[0x80131237]='Signature specified is zero-sized.'\nSymbolicName[0x80131239]='VLDTR_E_MD_BADCALLINGCONV'\nMessage[0x80131239]='Method signature has invalid calling convention.'\nComment[0x80131239]='Method signature has invalid calling convention.'\nSymbolicName[0x8013123a]='VLDTR_E_MD_THISSTATIC'\nMessage[0x8013123a]='Method is marked static but has HASTHIS/EXPLICITTHIS set on the calling convention.'\nComment[0x8013123a]='Method is marked static but has HASTHIS/EXPLICITTHIS set on the calling convention.'\nSymbolicName[0x8013123b]='VLDTR_E_MD_NOTTHISNOTSTATIC'\nMessage[0x8013123b]='Method is not marked static but is not HASTHIS or EXPLICITTHIS.'\nComment[0x8013123b]='Method is not marked static but is not HASTHIS/EXPLICITTHIS.'\nSymbolicName[0x8013123c]='VLDTR_E_MD_NOARGCNT'\nMessage[0x8013123c]='Method signature is missing the argument count.'\nComment[0x8013123c]='Method signature is missing the argument count.'\nSymbolicName[0x8013123d]='VLDTR_E_SIG_MISSELTYPE'\nMessage[0x8013123d]='Signature missing element type.'\nComment[0x8013123d]='Signature missing element type.'\nSymbolicName[0x8013123e]='VLDTR_E_SIG_MISSTKN'\nMessage[0x8013123e]='Signature missing token.'\nComment[0x8013123e]='Signature missing token.'\nSymbolicName[0x8013123f]='VLDTR_E_SIG_TKNBAD'\nMessage[0x8013123f]='Signature has bad token.'\nComment[0x8013123f]='Signature has bad token.'\nSymbolicName[0x80131240]='VLDTR_E_SIG_MISSFPTR'\nMessage[0x80131240]='Signature is missing function pointer.'\nComment[0x80131240]='Signature is missing function pointer.'\nSymbolicName[0x80131241]='VLDTR_E_SIG_MISSFPTRARGCNT'\nMessage[0x80131241]='Signature has function pointer missing argument count.'\nComment[0x80131241]='Signature has function pointer missing argument count.'\nSymbolicName[0x80131242]='VLDTR_E_SIG_MISSRANK'\nMessage[0x80131242]='Signature is missing rank specification.'\nComment[0x80131242]='Signature is missing rank specification.'\nSymbolicName[0x80131243]='VLDTR_E_SIG_MISSNSIZE'\nMessage[0x80131243]='Signature is missing count of sized dimensions.'\nComment[0x80131243]='Signature is missing count of sized dimensions.'\nSymbolicName[0x80131244]='VLDTR_E_SIG_MISSSIZE'\nMessage[0x80131244]='Signature is missing size of dimension.'\nComment[0x80131244]='Signature is missing size of dimension.'\nSymbolicName[0x80131245]='VLDTR_E_SIG_MISSNLBND'\nMessage[0x80131245]='Signature is missing count of lower bounds.'\nComment[0x80131245]='Signature is missing count of lower bounds.'\nSymbolicName[0x80131246]='VLDTR_E_SIG_MISSLBND'\nMessage[0x80131246]='Signature is missing a lower bound.'\nComment[0x80131246]='Signature is missing a lower bound.'\nSymbolicName[0x80131247]='VLDTR_E_SIG_BADELTYPE'\nMessage[0x80131247]='Signature has bad element type.'\nComment[0x80131247]='Signature has bad element type.'\nSymbolicName[0x80131256]='VLDTR_E_TD_ENCLNOTNESTED'\nMessage[0x80131256]='TypeDef not nested has encloser.'\nComment[0x80131256]='TypeDef not nested has encloser.'\nSymbolicName[0x80131277]='VLDTR_E_FMD_PINVOKENOTSTATIC'\nMessage[0x80131277]='Field or method is PInvoke but is not marked Static.'\nComment[0x80131277]='Field/method is PInvoke but is not marked Static.'\nSymbolicName[0x801312df]='VLDTR_E_SIG_SENTINMETHODDEF'\nMessage[0x801312df]='E_T_SENTINEL in MethodDef signature.'\nComment[0x801312df]='E_T_SENTINEL in MethodDef signature'\nSymbolicName[0x801312e0]='VLDTR_E_SIG_SENTMUSTVARARG'\nMessage[0x801312e0]='E_T_SENTINEL <=> VARARG.'\nComment[0x801312e0]='E_T_SENTINEL <=> VARARG'\nSymbolicName[0x801312e1]='VLDTR_E_SIG_MULTSENTINELS'\nMessage[0x801312e1]='Multiple E_T_SENTINELs.'\nComment[0x801312e1]='Multiple E_T_SENTINELs'\nSymbolicName[0x801312e3]='VLDTR_E_SIG_MISSARG'\nMessage[0x801312e3]='Signature missing argument.'\nComment[0x801312e3]='Signature missing argument'\nSymbolicName[0x801312e4]='VLDTR_E_SIG_BYREFINFIELD'\nMessage[0x801312e4]='Field of ByRef type.'\nComment[0x801312e4]='Field of ByRef type'\nSymbolicName[0x80131300]='CORDBG_E_UNRECOVERABLE_ERROR'\nMessage[0x80131300]='Unrecoverable API error.'\nComment[0x80131300]='Unrecoverable API error.'\nSymbolicName[0x80131301]='CORDBG_E_PROCESS_TERMINATED'\nMessage[0x80131301]='Process was terminated.'\nComment[0x80131301]='Process was terminated.'\nSymbolicName[0x80131302]='CORDBG_E_PROCESS_NOT_SYNCHRONIZED'\nMessage[0x80131302]='Process not synchronized.'\nComment[0x80131302]='Process not synchronized.'\nSymbolicName[0x80131303]='CORDBG_E_CLASS_NOT_LOADED'\nMessage[0x80131303]='A class is not loaded.'\nComment[0x80131303]='A class is not loaded.'\nSymbolicName[0x80131304]='CORDBG_E_IL_VAR_NOT_AVAILABLE'\nMessage[0x80131304]='An IL variable is not available at the current native IP.'\nComment[0x80131304]='An IL variable is not available at the'\nSymbolicName[0x80131305]='CORDBG_E_BAD_REFERENCE_VALUE'\nMessage[0x80131305]='A reference value was found to be bad during dereferencing.'\nComment[0x80131305]='A reference value was found to be bad'\nSymbolicName[0x80131306]='CORDBG_E_FIELD_NOT_AVAILABLE'\nMessage[0x80131306]='A field in a class is not available, because the runtime optimized it away.'\nComment[0x80131306]='A field in a class is not available,'\nSymbolicName[0x80131307]='CORDBG_E_NON_NATIVE_FRAME'\nMessage[0x80131307]=\"'Native-frame-only' operation on non-native frame.\"\nComment[0x80131307]='Native frame only\" operation on'\nSymbolicName[0x80131309]='CORDBG_E_CODE_NOT_AVAILABLE'\nMessage[0x80131309]='The code is currently unavailable.'\nComment[0x80131309]='The code is currently unavailable'\nSymbolicName[0x8013130a]='CORDBG_E_FUNCTION_NOT_IL'\nMessage[0x8013130a]='Attempt to get a ICorDebugFunction for a function that is not IL.'\nComment[0x8013130a]='Attempt to get a ICorDebugFunction for'\nSymbolicName[0x8013130e]='CORDBG_E_CANT_SET_IP_INTO_FINALLY'\nMessage[0x8013130e]='SetIP is not possible because SetIP would move EIP from outside of an exception handling finally clause to a point inside of one.'\nComment[0x8013130e]=\"SetIP isn't possible, because SetIP would\"\nSymbolicName[0x8013130f]='CORDBG_E_CANT_SET_IP_OUT_OF_FINALLY'\nMessage[0x8013130f]='SetIP is not possible because it would move EIP from within an exception handling finally clause to a point outside of one.'\nComment[0x8013130f]=\"SetIP isn't possible because it would move\"\nSymbolicName[0x80131310]='CORDBG_E_CANT_SET_IP_INTO_CATCH'\nMessage[0x80131310]='SetIP is not possible, because SetIP would move EIP from outside of an exception handling catch clause to a point inside of one.'\nComment[0x80131310]=\"SetIP isn't possible, because SetIP would\"\nSymbolicName[0x80131311]='CORDBG_E_SET_IP_NOT_ALLOWED_ON_NONLEAF_FRAME'\nMessage[0x80131311]='SetIP cannot be done on any frame except the leaf frame.'\nComment[0x80131311]='Setip cannot be done on any frame except'\nSymbolicName[0x80131312]='CORDBG_E_SET_IP_IMPOSSIBLE'\nMessage[0x80131312]='SetIP is not allowed.'\nComment[0x80131312]=\"SetIP isn't allowed. For example, there is\"\nSymbolicName[0x80131313]='CORDBG_E_FUNC_EVAL_BAD_START_POINT'\nMessage[0x80131313]='Func eval cannot work. Bad starting point.'\nComment[0x80131313]=\"Func eval can't work if we're, for example,\"\nSymbolicName[0x80131314]='CORDBG_E_INVALID_OBJECT'\nMessage[0x80131314]='This object value is no longer valid.'\nComment[0x80131314]='This object value is no longer valid.'\nSymbolicName[0x80131315]='CORDBG_E_FUNC_EVAL_NOT_COMPLETE'\nMessage[0x80131315]='CordbEval::GetResult called before func eval has finished.'\nComment[0x80131315]='If you call CordbEval::GetResult before the'\nSymbolicName[0x8013131a]='CORDBG_E_STATIC_VAR_NOT_AVAILABLE'\nMessage[0x8013131a]='A static variable is not available because it has not been initialized yet.'\nComment[0x8013131a]=\"A static variable isn't available because\"\nSymbolicName[0x8013131c]='CORDBG_E_CANT_SETIP_INTO_OR_OUT_OF_FILTER'\nMessage[0x8013131c]='SetIP cannot leave or enter a filter.'\nComment[0x8013131c]=\"SetIP can't leave or enter a filter\"\nSymbolicName[0x8013131d]='CORDBG_E_CANT_CHANGE_JIT_SETTING_FOR_ZAP_MODULE'\nMessage[0x8013131d]='JIT settings for ZAP modules cannot be changed.'\nComment[0x8013131d]=\"You can't change JIT settings for ZAP\"\nSymbolicName[0x8013131e]='CORDBG_E_CANT_SET_IP_OUT_OF_FINALLY_ON_WIN64'\nMessage[0x8013131e]='SetIP is not possible because it would move EIP from within a finally clause to a point outside of one on this platforms.'\nComment[0x8013131e]=\"SetIP isn't possible because it would move\"\nSymbolicName[0x8013131f]='CORDBG_E_CANT_SET_IP_OUT_OF_CATCH_ON_WIN64'\nMessage[0x8013131f]='SetIP is not possible because it would move EIP from within a catch clause to a point outside of one on this platforms.'\nComment[0x8013131f]=\"SetIP isn't possible because it would move\"\nSymbolicName[0x80131323]='CORDBG_E_CANT_SET_TO_JMC'\nMessage[0x80131323]='Cannot use JMC on this code (likely wrong JIT settings).'\nComment[0x80131323]=\"Can't use JMC on this code (likely wrong jit settings).\"\nSymbolicName[0x80131325]='CORDBG_E_NO_CONTEXT_FOR_INTERNAL_FRAME'\nMessage[0x80131325]='Internal frame markers have no associated context.'\nComment[0x80131325]='Internal frame markers have no associated context.'\nSymbolicName[0x80131326]='CORDBG_E_NOT_CHILD_FRAME'\nMessage[0x80131326]='The current frame is not a child frame.'\nComment[0x80131326]='The current frame is not a child frame.'\nSymbolicName[0x80131327]='CORDBG_E_NON_MATCHING_CONTEXT'\nMessage[0x80131327]='The provided CONTEXT does not match the specified thread.'\nComment[0x80131327]='The provided CONTEXT does not match the specified thread.\\n    The stack pointer in the provided CONTEXT must match the cached stack base and stack limit of the thread.\\n'\nSymbolicName[0x80131328]='CORDBG_E_PAST_END_OF_STACK'\nMessage[0x80131328]='The stackwalker is now past the end of stack.  No information is available.'\nComment[0x80131328]='The stackwalker is now past the end of stack.  No information is available.'\nSymbolicName[0x80131329]='CORDBG_E_FUNC_EVAL_CANNOT_UPDATE_REGISTER_IN_NONLEAF_FRAME'\nMessage[0x80131329]='Func eval cannot update a variable stored in a register on a non-leaf frame.  The most likely cause is that such a variable is passed as a ref/out argument.'\nComment[0x80131329]='Func eval cannot update a variable stored in a register on a non-leaf frame.  The most likely cause is that such a variable is passed as a ref/out argument.'\nSymbolicName[0x8013132d]='CORDBG_E_BAD_THREAD_STATE'\nMessage[0x8013132d]='The state of the thread is invalid.'\nComment[0x8013132d]='The state of the thread is invalid.'\nSymbolicName[0x8013132e]='CORDBG_E_DEBUGGER_ALREADY_ATTACHED'\nMessage[0x8013132e]='This process has already been attached.'\nComment[0x8013132e]='This process has already been attached to'\nSymbolicName[0x8013132f]='CORDBG_E_SUPERFLOUS_CONTINUE'\nMessage[0x8013132f]='Returned from a call to Continue that was not matched with a stopping event.'\nComment[0x8013132f]='Returned from a call to Continue that was'\nSymbolicName[0x80131330]='CORDBG_E_SET_VALUE_NOT_ALLOWED_ON_NONLEAF_FRAME'\nMessage[0x80131330]='Cannot perfrom SetValue on non-leaf frames.'\nComment[0x80131330]=\"Can't perfrom SetValue on non-leaf frames.\"\nSymbolicName[0x80131332]='CORDBG_E_ENC_MODULE_NOT_ENC_ENABLED'\nMessage[0x80131332]='Tried to do Edit and Continue on a module that was not started in Edit and Continue mode.'\nComment[0x80131332]=\"Tried to do EnC on a module that wasn't\"\nSymbolicName[0x80131333]='CORDBG_E_SET_IP_NOT_ALLOWED_ON_EXCEPTION'\nMessage[0x80131333]='SetIP cannot be done on any exception.'\nComment[0x80131333]='Setip cannot be done on any exception'\nSymbolicName[0x80131334]='CORDBG_E_VARIABLE_IS_ACTUALLY_LITERAL'\nMessage[0x80131334]=\"The 'variable' does not exist because it is a literal optimized away by the compiler.\"\nComment[0x80131334]=\"The 'variable' doesn't exist because it is a\"\nSymbolicName[0x80131335]='CORDBG_E_PROCESS_DETACHED'\nMessage[0x80131335]='Process has been detached.'\nComment[0x80131335]='Process has been detached from'\nSymbolicName[0x80131338]='CORDBG_E_ENC_CANT_ADD_FIELD_TO_VALUE_OR_LAYOUT_CLASS'\nMessage[0x80131338]='Adding a field to a value or layout class is prohibited.'\nComment[0x80131338]='Adding a field to a value or layout class is prohibitted,'\nSymbolicName[0x8013133b]='CORDBG_E_FIELD_NOT_STATIC'\nMessage[0x8013133b]='GetStaticFieldValue called on a non-static field.'\nComment[0x8013133b]='Returned if someone tries to call GetStaticFieldValue'\nSymbolicName[0x8013133c]='CORDBG_E_FIELD_NOT_INSTANCE'\nMessage[0x8013133c]='Returned if someone tries to call GetStaticFieldValue on a non-instance field.'\nComment[0x8013133c]='Returned if someone tries to call GetStaticFieldValue'\nSymbolicName[0x8013133f]='CORDBG_E_ENC_JIT_CANT_UPDATE'\nMessage[0x8013133f]='The JIT is unable to update the method.'\nComment[0x8013133f]='The JIT is unable to update the method.'\nSymbolicName[0x80131341]='CORDBG_E_ENC_INTERNAL_ERROR'\nMessage[0x80131341]='Internal Runtime Error while doing Edit-and-Continue.'\nComment[0x80131341]='Generic message for \"Something user doesn\\'t control went wrong\" message.'\nSymbolicName[0x80131342]='CORDBG_E_ENC_HANGING_FIELD'\nMessage[0x80131342]='The field was added via Edit and Continue after the class was loaded.'\nComment[0x80131342]=\"The field was added via EnC after the class was loaded, and so instead of the the field being contiguous with the other fields, it's 'hanging' off the instance or type.  This error is used to indicate that either the storage for this field is not yet available and so the field value cannot be read, or the debugger needs to use an EnC specific code path to get the value.\"\nSymbolicName[0x80131343]='CORDBG_E_MODULE_NOT_LOADED'\nMessage[0x80131343]='Module not loaded.'\nComment[0x80131343]=\"If the module isn't loaded, including if it's been unloaded.\"\nSymbolicName[0x80131345]='CORDBG_E_UNABLE_TO_SET_BREAKPOINT'\nMessage[0x80131345]='Cannot set a breakpoint here.'\nComment[0x80131345]=\"Can't set a breakpoint here.\"\nSymbolicName[0x80131346]='CORDBG_E_DEBUGGING_NOT_POSSIBLE'\nMessage[0x80131346]='Debugging is not possible due to an incompatibility within the CLR implementation.'\nComment[0x80131346]=\"Debugging isn't possible due to an incompatibility within the CLR implementation.\"\nSymbolicName[0x80131347]='CORDBG_E_KERNEL_DEBUGGER_ENABLED'\nMessage[0x80131347]='A kernel debugger is enabled on the system.  User-mode debugging will trap to the kernel debugger.'\nComment[0x80131347]=\"Debugging isn't possible because a kernel debugger is enabled on the system.\"\nSymbolicName[0x80131348]='CORDBG_E_KERNEL_DEBUGGER_PRESENT'\nMessage[0x80131348]='A kernel debugger is present on the system.  User-mode debugging will trap to the kernel debugger.'\nComment[0x80131348]=\"Debugging isn't possible because a kernel debugger is present on the system.\"\nSymbolicName[0x8013134b]='CORDBG_E_INCOMPATIBLE_PROTOCOL'\nMessage[0x8013134b]=\"The debugger's protocol is incompatible with the debuggee.\"\nComment[0x8013134b]=\"The debugger's protocol is incompatible with the debuggee.\"\nSymbolicName[0x8013134c]='CORDBG_E_TOO_MANY_PROCESSES'\nMessage[0x8013134c]='The debugger can only handle a finite number of debuggees.'\nComment[0x8013134c]='The debugger can only handle a finite number of debuggees.'\nSymbolicName[0x8013134d]='CORDBG_E_INTEROP_NOT_SUPPORTED'\nMessage[0x8013134d]='Interop debugging is not supported.'\nComment[0x8013134d]='Interop debugging is not supported'\nSymbolicName[0x8013134e]='CORDBG_E_NO_REMAP_BREAKPIONT'\nMessage[0x8013134e]='Cannot call RemapFunction until have received RemapBreakpoint.'\nComment[0x8013134e]='Cannot call RemapFunction until have received RemapBreakpoint'\nSymbolicName[0x8013134f]='CORDBG_E_OBJECT_NEUTERED'\nMessage[0x8013134f]='Object is in a zombie state.'\nComment[0x8013134f]=\"Object has been neutered (it's in a zombie state).\"\nSymbolicName[0x80131350]='CORPROF_E_FUNCTION_NOT_COMPILED'\nMessage[0x80131350]='Function not yet compiled.'\nComment[0x80131350]='Function not yet compiled.'\nSymbolicName[0x80131351]='CORPROF_E_DATAINCOMPLETE'\nMessage[0x80131351]='The ID is not fully loaded/defined yet.'\nComment[0x80131351]='The ID is not fully loaded/defined yet.'\nSymbolicName[0x80131354]='CORPROF_E_FUNCTION_NOT_IL'\nMessage[0x80131354]='The Method has no associated IL.'\nComment[0x80131354]='The Method has no associated IL'\nSymbolicName[0x80131355]='CORPROF_E_NOT_MANAGED_THREAD'\nMessage[0x80131355]='The thread has never run managed code before.'\nComment[0x80131355]='The thread has never run managed code before'\nSymbolicName[0x80131356]='CORPROF_E_CALL_ONLY_FROM_INIT'\nMessage[0x80131356]='The function may only be called during profiler initialization.'\nComment[0x80131356]='The function may only be called during profiler init'\nSymbolicName[0x8013135b]='CORPROF_E_NOT_YET_AVAILABLE'\nMessage[0x8013135b]='Requested information is not yet available.'\nComment[0x8013135b]='This is a general error used to indicated that the information'\nSymbolicName[0x8013135c]='CORPROF_E_TYPE_IS_PARAMETERIZED'\nMessage[0x8013135c]='The given type is a generic and cannot be used with this method.'\nComment[0x8013135c]='The given type is a generic and cannot be used with this method.'\nSymbolicName[0x8013135d]='CORPROF_E_FUNCTION_IS_PARAMETERIZED'\nMessage[0x8013135d]='The given function is a generic and cannot be used with this method.'\nComment[0x8013135d]='The given function is a generic and cannot be used with this method.'\nSymbolicName[0x8013135e]='CORPROF_E_STACKSNAPSHOT_INVALID_TGT_THREAD'\nComment[0x8013135e]='A profiler tried to walk the stack of an invalid thread'\nSymbolicName[0x8013135f]='CORPROF_E_STACKSNAPSHOT_UNMANAGED_CTX'\nComment[0x8013135f]='A profiler can not walk a thread that is currently executing unmanaged code'\nSymbolicName[0x80131360]='CORPROF_E_STACKSNAPSHOT_UNSAFE'\nComment[0x80131360]='A stackwalk at this point may cause dead locks or data corruption'\nSymbolicName[0x80131361]='CORPROF_E_STACKSNAPSHOT_ABORTED'\nComment[0x80131361]='Stackwalking callback requested the walk to abort'\nSymbolicName[0x80131362]='CORPROF_E_LITERALS_HAVE_NO_ADDRESS'\nComment[0x80131362]='Returned when asked for the address of a static that is a literal.'\nSymbolicName[0x80131363]='CORPROF_E_UNSUPPORTED_CALL_SEQUENCE'\nComment[0x80131363]='A call was made at an unsupported time.  Examples include illegally calling a profiling API method asynchronously, calling a method that might trigger a GC at an unsafe time, and calling a method at a time that could cause locks to be taken out of order.'\nSymbolicName[0x80131364]='CORPROF_E_ASYNCHRONOUS_UNSAFE'\nComment[0x80131364]='A legal asynchronous call was made at an unsafe time (e.g., CLR locks are held)'\nSymbolicName[0x80131365]='CORPROF_E_CLASSID_IS_ARRAY'\nComment[0x80131365]='The specified ClassID cannot be inspected by this function because it is an array'\nSymbolicName[0x80131366]='CORPROF_E_CLASSID_IS_COMPOSITE'\nComment[0x80131366]='The specified ClassID is a non-array composite type (e.g., ref) and cannot be inspected'\nSymbolicName[0x80131367]='CORPROF_E_PROFILER_DETACHING'\nComment[0x80131367]=\"The profiler's call into the CLR is disallowed because the profiler is attempting to detach.\"\nSymbolicName[0x80131368]='CORPROF_E_PROFILER_NOT_ATTACHABLE'\nComment[0x80131368]='The profiler does not support attaching to a live process.'\nSymbolicName[0x80131369]='CORPROF_E_UNRECOGNIZED_PIPE_MSG_FORMAT'\nComment[0x80131369]='The message sent on the profiling API attach pipe is in an unrecognized format.'\nSymbolicName[0x8013136a]='CORPROF_E_PROFILER_ALREADY_ACTIVE'\nComment[0x8013136a]='The request to attach a profiler was denied because a profiler is already loaded.'\nSymbolicName[0x8013136b]='CORPROF_E_PROFILEE_INCOMPATIBLE_WITH_TRIGGER'\nComment[0x8013136b]=\"Unable to request a profiler attach because the target profilee's runtime is of a version incompatible with the current process calling AttachProfiler().\"\nSymbolicName[0x8013136c]='CORPROF_E_IPC_FAILED'\nComment[0x8013136c]='AttachProfiler() encountered an error while communicating on the pipe to the target profilee.  This is often caused by a target profilee that is shutting down or killed while AttachProfiler() is reading or writing the pipe.'\nSymbolicName[0x8013136d]='CORPROF_E_PROFILEE_PROCESS_NOT_FOUND'\nComment[0x8013136d]='AttachProfiler() was unable to find a profilee with the specified process ID.'\nSymbolicName[0x8013136e]='CORPROF_E_CALLBACK3_REQUIRED'\nComment[0x8013136e]='Profiler must implement ICorProfilerCallback3 interface for this call to be supported.'\nSymbolicName[0x8013136f]='CORPROF_E_UNSUPPORTED_FOR_ATTACHING_PROFILER'\nComment[0x8013136f]='This call was attempted by a profiler that attached to the process after startup, but this call is only supported by profilers that are loaded into the process on startup.'\nSymbolicName[0x80131370]='CORPROF_E_IRREVERSIBLE_INSTRUMENTATION_PRESENT'\nComment[0x80131370]='Detach is impossible because the profiler has either instrumented IL or inserted enter/leave hooks. Detach was not attempted; the profiler is still fully attached.'\nSymbolicName[0x80131371]='CORPROF_E_RUNTIME_UNINITIALIZED'\nComment[0x80131371]='The profiler called a function that cannot complete because the CLR is not yet fully initialized.  The profiler may try again once the CLR has fully started.'\nSymbolicName[0x80131372]='CORPROF_E_IMMUTABLE_FLAGS_SET'\nComment[0x80131372]='Detach is impossible because immutable flags were set by the profiler at startup. Detach was not attempted; the profiler is still fully attached.'\nSymbolicName[0x80131373]='CORPROF_E_PROFILER_NOT_YET_INITIALIZED'\nComment[0x80131373]='The profiler called a function that cannot complete because the profiler is not yet fully initialized.'\nSymbolicName[0x80131374]='CORPROF_E_INCONSISTENT_WITH_FLAGS'\nComment[0x80131374]='The profiler called a function that first requires additional flags to be set in the event mask.  This HRESULT may also indicate that the profiler called a function that first requires that some of the flags currently set in the event mask be reset.'\nSymbolicName[0x80131375]='CORPROF_E_PROFILER_CANCEL_ACTIVATION'\nComment[0x80131375]='The profiler has requested that the CLR instance not load the profiler into this process.'\nSymbolicName[0x80131376]='CORPROF_E_CONCURRENT_GC_NOT_PROFILABLE'\nComment[0x80131376]='Concurrent GC mode is enabled, which prevents use of COR_PRF_MONITOR_GC'\nSymbolicName[0x80131378]='CORPROF_E_DEBUGGING_DISABLED'\nComment[0x80131378]='This functionality requires CoreCLR debugging to be enabled.'\nSymbolicName[0x80131379]='CORPROF_E_TIMEOUT_WAITING_FOR_CONCURRENT_GC'\nComment[0x80131379]='Timed out on waiting for concurrent GC to finish during attach.'\nSymbolicName[0x8013137a]='CORPROF_E_MODULE_IS_DYNAMIC'\nComment[0x8013137a]='The specified module was dynamically generated (e.g., via Reflection.Emit API), and is thus not supported by this API method.'\nSymbolicName[0x8013137b]='CORPROF_E_CALLBACK4_REQUIRED'\nComment[0x8013137b]='Profiler must implement ICorProfilerCallback4 interface for this call to be supported.'\nSymbolicName[0x8013137c]='CORPROF_E_REJIT_NOT_ENABLED'\nComment[0x8013137c]='This call is not supported unless ReJIT is first enabled during initialization by setting COR_PRF_ENABLE_REJIT via SetEventMask.'\nSymbolicName[0x8013137e]='CORPROF_E_FUNCTION_IS_COLLECTIBLE'\nComment[0x8013137e]='The specified function is instantiated into a collectible assembly, and is thus not supported by this API method.'\nSymbolicName[0x80131380]='CORPROF_E_CALLBACK6_REQUIRED'\nComment[0x80131380]='Profiler must implement ICorProfilerCallback6 interface for this call to be supported.'\nSymbolicName[0x80131382]='CORPROF_E_CALLBACK7_REQUIRED'\nComment[0x80131382]='Profiler must implement ICorProfilerCallback7 interface for this call to be supported.'\nSymbolicName[0x80131383]='CORPROF_E_REJIT_INLINING_DISABLED'\nComment[0x80131383]=\"The runtime's tracking of inlined methods for ReJIT is not enabled.\"\nSymbolicName[0x80131384]='CORDIAGIPC_E_BAD_ENCODING'\nComment[0x80131384]='The runtime was unable to decode the Header or Payload.'\nSymbolicName[0x80131385]='CORDIAGIPC_E_UNKNOWN_COMMAND'\nComment[0x80131385]='The specified CommandSet or CommandId is unknown.'\nSymbolicName[0x80131386]='CORDIAGIPC_E_UNKNOWN_MAGIC'\nComment[0x80131386]='The magic version of Diagnostics IPC is unknown.'\nSymbolicName[0x80131387]='CORDIAGIPC_E_UNKNOWN_ERROR'\nComment[0x80131387]='An unknown error occurred in the Diagnpostics IPC Server.'\nSymbolicName[0x80131388]='CORPROF_E_SUSPENSION_IN_PROGRESS'\nComment[0x80131388]='The runtime cannot be suspened since a suspension is already in progress.'\nSymbolicName[0x80131401]='SECURITY_E_INCOMPATIBLE_SHARE'\nMessage[0x80131401]='Loading this assembly would produce a different grant set from other instances.'\nComment[0x80131401]='Loading this assembly would produce a different grant set from other instances'\nSymbolicName[0x80131402]='SECURITY_E_UNVERIFIABLE'\nMessage[0x80131402]='Unverifiable code failed policy check.'\nComment[0x80131402]='Unverifable code failed policy check'\nSymbolicName[0x80131403]='SECURITY_E_INCOMPATIBLE_EVIDENCE'\nMessage[0x80131403]='Assembly already loaded without additional security evidence.'\nComment[0x80131403]='Assembly already loaded without additional security evidence.'\nSymbolicName[0x80131416]='CORSEC_E_POLICY_EXCEPTION'\nMessage[0x80131416]='PolicyException thrown.'\nComment[0x80131416]='PolicyException thrown'\nSymbolicName[0x80131417]='CORSEC_E_MIN_GRANT_FAIL'\nMessage[0x80131417]='Failed to grant minimum permission requests.'\nComment[0x80131417]='Failed to grant minimum permission requests'\nSymbolicName[0x80131418]='CORSEC_E_NO_EXEC_PERM'\nMessage[0x80131418]='Failed to grant permission to execute.'\nComment[0x80131418]='Failed to grant permission to execute'\nSymbolicName[0x80131419]='CORSEC_E_XMLSYNTAX'\nMessage[0x80131419]='XML Syntax error.'\nComment[0x80131419]='XML Syntax error'\nSymbolicName[0x8013141a]='CORSEC_E_INVALID_STRONGNAME'\nMessage[0x8013141a]='Strong name validation failed.'\nComment[0x8013141a]='Strong name validation failed'\nSymbolicName[0x8013141b]='CORSEC_E_MISSING_STRONGNAME'\nMessage[0x8013141b]='Assembly is not strong named.'\nComment[0x8013141b]='Assembly is not strong named'\nSymbolicName[0x8013141d]='CORSEC_E_INVALID_IMAGE_FORMAT'\nMessage[0x8013141d]='Invalid assembly file format.'\nComment[0x8013141d]='Invalid assembly file format'\nSymbolicName[0x8013141e]='CORSEC_E_INVALID_PUBLICKEY'\nMessage[0x8013141e]='Invalid assembly public key.'\nComment[0x8013141e]='Invalid assembly public key'\nSymbolicName[0x80131420]='CORSEC_E_SIGNATURE_MISMATCH'\nMessage[0x80131420]='Signature size mismatch.'\nComment[0x80131420]='Signature size mismatch'\nSymbolicName[0x80131430]='CORSEC_E_CRYPTO'\nMessage[0x80131430]='Failure during Cryptographic operation.'\nComment[0x80131430]='generic CryptographicException'\nSymbolicName[0x80131431]='CORSEC_E_CRYPTO_UNEX_OPER'\nMessage[0x80131431]='Unexpected Cryptographic operation.'\nComment[0x80131431]='generic CryptographicUnexpectedOperationException'\nSymbolicName[0x80131442]='CORSECATTR_E_BAD_ACTION'\nMessage[0x80131442]='Invalid security action code.'\nComment[0x80131442]='Invalid security action code'\nSymbolicName[0x80131500]='COR_E_EXCEPTION'\nMessage[0x80131500]='General Exception'\nComment[0x80131500]='Base class for all exceptions in the runtime'\nSymbolicName[0x80131501]='COR_E_SYSTEM'\nMessage[0x80131501]='System.Exception'\nComment[0x80131501]='The base class for the runtime\\'s \"less serious\" exceptions'\nSymbolicName[0x80131502]='COR_E_ARGUMENTOUTOFRANGE'\nMessage[0x80131502]='An argument was out of its legal range.'\nComment[0x80131502]='An argument was out of its legal range.'\nSymbolicName[0x80131503]='COR_E_ARRAYTYPEMISMATCH'\nMessage[0x80131503]='Attempted to store an object of the wrong type in an array.'\nComment[0x80131503]='Attempted to store an object of the wrong type in an array'\nSymbolicName[0x80131504]='COR_E_CONTEXTMARSHAL'\nMessage[0x80131504]='Attempted to marshal an object across a context boundary.'\nSymbolicName[0x80131505]='COR_E_TIMEOUT'\nMessage[0x80131505]='Operation timed out.'\nSymbolicName[0x80131506]='COR_E_EXECUTIONENGINE'\nMessage[0x80131506]='Internal CLR error.'\nComment[0x80131506]=\"An internal error happened in the Common Language Runtime's Execution Engine\"\nSymbolicName[0x80131507]='COR_E_FIELDACCESS'\nMessage[0x80131507]='Access to this field is denied.'\nComment[0x80131507]='Access to this field is denied.'\nSymbolicName[0x80131508]='COR_E_INDEXOUTOFRANGE'\nMessage[0x80131508]='Array subscript out of range.'\nComment[0x80131508]='Attempted to access an element within an array by using an index that is'\nSymbolicName[0x80131509]='COR_E_INVALIDOPERATION'\nMessage[0x80131509]='An operation is not legal in the current state.'\nComment[0x80131509]='An operation is not legal in the current state.'\nSymbolicName[0x8013150a]='COR_E_SECURITY'\nMessage[0x8013150a]='An error relating to security occurred.'\nComment[0x8013150a]='An error relating to security occurred.'\nSymbolicName[0x8013150c]='COR_E_SERIALIZATION'\nMessage[0x8013150c]='An error relating to serialization occurred.'\nComment[0x8013150c]='An error relating to serialization has occurred.'\nSymbolicName[0x8013150d]='COR_E_VERIFICATION'\nMessage[0x8013150d]='A verification failure has occurred.'\nComment[0x8013150d]='A verification failure occurred'\nSymbolicName[0x80131510]='COR_E_METHODACCESS'\nMessage[0x80131510]='Access to this method is denied.'\nComment[0x80131510]='Access to this method is denied.'\nSymbolicName[0x80131511]='COR_E_MISSINGFIELD'\nMessage[0x80131511]='Field does not exist.'\nComment[0x80131511]='An attempt was made to dynamically access a field that does not exist.'\nSymbolicName[0x80131512]='COR_E_MISSINGMEMBER'\nMessage[0x80131512]='Member does not exist.'\nComment[0x80131512]='An attempt was made to dynamically invoke or access a field or method'\nSymbolicName[0x80131513]='COR_E_MISSINGMETHOD'\nMessage[0x80131513]='Method does not exist.'\nComment[0x80131513]='An attempt was made to dynamically invoke a method that does not exist'\nSymbolicName[0x80131514]='COR_E_MULTICASTNOTSUPPORTED'\nMessage[0x80131514]='Attempt to combine delegates that are not multicast.'\nComment[0x80131514]='Attempted to combine delegates that are not multicast'\nSymbolicName[0x80131515]='COR_E_NOTSUPPORTED'\nMessage[0x80131515]='Operation is not supported.'\nComment[0x80131515]='The operation is not supported'\nSymbolicName[0x80131516]='COR_E_OVERFLOW'\nMessage[0x80131516]='Arithmetic, casting or conversion operation overflowed or underflowed.'\nComment[0x80131516]='An arithmetic, casting, or conversion operation overflowed or underflowed.'\nSymbolicName[0x80131517]='COR_E_RANK'\nMessage[0x80131517]='An array has the wrong number of dimensions for a particular operation.'\nComment[0x80131517]='An array has the wrong number of dimensions for a particular operation.'\nSymbolicName[0x80131518]='COR_E_SYNCHRONIZATIONLOCK'\nMessage[0x80131518]='This operation must be called from a synchronized block.'\nComment[0x80131518]='Wait(), Notify() or NotifyAll() was called from an unsynchronized ** block of c'\nSymbolicName[0x80131519]='COR_E_THREADINTERRUPTED'\nMessage[0x80131519]='Thread was interrupted from a waiting state.'\nComment[0x80131519]='Indicates that the thread was interrupted from a waiting state'\nSymbolicName[0x8013151a]='COR_E_MEMBERACCESS'\nMessage[0x8013151a]='Access to this member is denied.'\nComment[0x8013151a]='Access to this member is denied.'\nSymbolicName[0x80131520]='COR_E_THREADSTATE'\nMessage[0x80131520]='Thread is in an invalid state for this operation.'\nComment[0x80131520]='Indicate that the Thread class is in an invalid state for the method call'\nSymbolicName[0x80131521]='COR_E_THREADSTOP'\nMessage[0x80131521]='Thread is stopping.'\nComment[0x80131521]='Thrown into a thread to cause it to stop. This exception is typically not caught'\nSymbolicName[0x80131522]='COR_E_TYPELOAD'\nMessage[0x80131522]='Could not find or load a type.'\nComment[0x80131522]='Could not find or load a specific type (class, enum, etc).'\nSymbolicName[0x80131523]='COR_E_ENTRYPOINTNOTFOUND'\nMessage[0x80131523]='Could not find the specified DllImport entrypoint.'\nComment[0x80131523]='Could not find the specified DllImport entry point'\nSymbolicName[0x80131524]='COR_E_DLLNOTFOUND'\nMessage[0x80131524]='Could not find the specified DllImport Dll.'\nComment[0x80131524]='Could not find the specified DllImport DLL.'\nSymbolicName[0x80131525]='COR_E_THREADSTART'\nComment[0x80131525]='Indicate that a user thread fails to start.'\nSymbolicName[0x80131527]='COR_E_INVALIDCOMOBJECT'\nMessage[0x80131527]='An invalid __ComObject has been used.'\nComment[0x80131527]='An invalid __ComObject has been used.'\nSymbolicName[0x80131528]='COR_E_NOTFINITENUMBER'\nMessage[0x80131528]='Not a Number.'\nComment[0x80131528]='Thrown if value (a floating point number) is either the not a number value (NaN) or +- infinity value'\nSymbolicName[0x80131529]='COR_E_DUPLICATEWAITOBJECT'\nMessage[0x80131529]='An object appears more than once in the wait objects array.'\nComment[0x80131529]='An object appears more than once in the wait objects array.'\nSymbolicName[0x8013152b]='COR_E_SEMAPHOREFULL'\nMessage[0x8013152b]='Reached maximum count for semaphore.'\nComment[0x8013152b]='Adding the given count to the semaphore would cause it to exceed its maximum count.'\nSymbolicName[0x8013152c]='COR_E_WAITHANDLECANNOTBEOPENED'\nMessage[0x8013152c]='No semaphore of the given name exists.'\nComment[0x8013152c]='No Semaphore of the given name exists.'\nSymbolicName[0x8013152d]='COR_E_ABANDONEDMUTEX'\nMessage[0x8013152d]='The wait completed due to an abandoned mutex.'\nComment[0x8013152d]='The wait completed due to an abandoned mutex.'\nSymbolicName[0x80131530]='COR_E_THREADABORTED'\nMessage[0x80131530]='Thread has aborted.'\nComment[0x80131530]='Thrown into a thread to cause it to abort. Not catchable.'\nSymbolicName[0x80131531]='COR_E_INVALIDOLEVARIANTTYPE'\nMessage[0x80131531]='OLE Variant has an invalid type.'\nComment[0x80131531]='The type of an OLE variant that was passed into the runtime is invalid.'\nSymbolicName[0x80131532]='COR_E_MISSINGMANIFESTRESOURCE'\nMessage[0x80131532]='An expected resource in the assembly manifest was missing.'\nComment[0x80131532]='An expected resource in the assembly manifest was missing.'\nSymbolicName[0x80131533]='COR_E_SAFEARRAYTYPEMISMATCH'\nMessage[0x80131533]='A mismatch has occurred between the runtime type of the array and the sub type recorded in the metadata.'\nComment[0x80131533]='A mismatch has occurred between the runtime type of the array and the subtype recorded in the metadata'\nSymbolicName[0x80131534]='COR_E_TYPEINITIALIZATION'\nMessage[0x80131534]='Uncaught exception during type initialization.'\nComment[0x80131534]=\"An exception was thrown by a type's initializer (.cctor).\"\nSymbolicName[0x80131535]='COR_E_MARSHALDIRECTIVE'\nMessage[0x80131535]='Invalid marshaling directives.'\nComment[0x80131535]='The marshaling directives are invalid.'\nSymbolicName[0x80131536]='COR_E_MISSINGSATELLITEASSEMBLY'\nMessage[0x80131536]='An expected satellite assembly containing the ultimate fallback resources for a given culture was not found or could not be loaded.'\nComment[0x80131536]='An expected satellite assembly containing the ultimate fallback resources'\nSymbolicName[0x80131537]='COR_E_FORMAT'\nMessage[0x80131537]='The format of one argument does not meet the contract of the method.'\nComment[0x80131537]='The format of one argument does not meet the contract of the method.'\nSymbolicName[0x80131538]='COR_E_SAFEARRAYRANKMISMATCH'\nMessage[0x80131538]='A mismatch has occurred between the runtime rank of the array and the rank recorded in the metadata.'\nComment[0x80131538]='A mismatch has occurred between the runtime rank of the array and the rank recorded in the metadata'\nSymbolicName[0x80131539]='COR_E_PLATFORMNOTSUPPORTED'\nMessage[0x80131539]='Operation is not supported on this platform.'\nComment[0x80131539]='The method is not supported on this platform'\nSymbolicName[0x8013153a]='COR_E_INVALIDPROGRAM'\nMessage[0x8013153a]='Invalid IL or CLR metadata.'\nComment[0x8013153a]='A program contained invalid IL or bad metadata.  Usually this is a compiler bug.'\nSymbolicName[0x8013153b]='COR_E_OPERATIONCANCELED'\nMessage[0x8013153b]='The operation was cancelled.'\nComment[0x8013153b]='The operation was cancelled.'\nSymbolicName[0x8013153d]='COR_E_INSUFFICIENTMEMORY'\nComment[0x8013153d]='Not enough memory was available for an operation.'\nSymbolicName[0x8013153e]='COR_E_RUNTIMEWRAPPED'\nComment[0x8013153e]='An object that does not derive from System.Exception has been wrapped in a RuntimeWrappedException.'\nSymbolicName[0x80131541]='COR_E_DATAMISALIGNED'\nMessage[0x80131541]='A datatype misalignment was detected in a load or store instruction.'\nComment[0x80131541]='A datatype misalignment was detected in a load or store instruction.'\nSymbolicName[0x80131542]='COR_E_CODECONTRACTFAILED'\nMessage[0x80131542]='A managed code contract (ie, precondition, postcondition, invariant, or assert) failed.'\nComment[0x80131542]='A managed code contract (ie, precondition, postcondition, invariant, or assert) failed.'\nSymbolicName[0x80131543]='COR_E_TYPEACCESS'\nMessage[0x80131543]='Access to this type is denied.'\nComment[0x80131543]='Access to this type is denied.'\nSymbolicName[0x80131544]='COR_E_ACCESSING_CCW'\nMessage[0x80131544]='Fail to access a CCW because the corresponding managed object is already collected.'\nComment[0x80131544]='Fail to access a CCW because the corresponding managed object is already collected.'\nSymbolicName[0x80131577]='COR_E_KEYNOTFOUND'\nMessage[0x80131577]='The given key was not present in the dictionary.'\nSymbolicName[0x80131578]='COR_E_INSUFFICIENTEXECUTIONSTACK'\nMessage[0x80131578]='Insufficient stack to continue executing the program safely. This can happen from having too many functions on the call stack or function on the stack using too much stack space.'\nComment[0x80131578]='Insufficient stack to continue executing the program safely. This can happen from having too many functions on the call stack or function on the stack using too much stack space.'\nSymbolicName[0x80131600]='COR_E_APPLICATION'\nMessage[0x80131600]='Application exception'\nComment[0x80131600]='The base class for all \"less serious\" exceptions.'\nSymbolicName[0x80131601]='COR_E_INVALIDFILTERCRITERIA'\nMessage[0x80131601]='The given filter criteria does not match the filter content.'\nComment[0x80131601]='The given filter criteria does not match the filter contract.'\nSymbolicName[0x80131602]='COR_E_REFLECTIONTYPELOAD'\nMessage[0x80131602]='Could not find or load a specific class that was requested through Reflection.'\nComment[0x80131602]='Could not find or load a specific class that was requested through Reflection'\nSymbolicName[0x80131603]='COR_E_TARGET'\nMessage[0x80131603]='Attempt to invoke non-static method with a null Object.'\nComment[0x80131603]='- If you attempt to invoke a non-static method with a null Object - If you atte'\nSymbolicName[0x80131604]='COR_E_TARGETINVOCATION'\nMessage[0x80131604]='Uncaught exception thrown by method called through Reflection.'\nComment[0x80131604]='If the method called throws an exception'\nSymbolicName[0x80131605]='COR_E_CUSTOMATTRIBUTEFORMAT'\nMessage[0x80131605]='Custom attribute has invalid format.'\nComment[0x80131605]='If the binary format of a custom attribute is invalid.'\nSymbolicName[0x80131620]='COR_E_IO'\nMessage[0x80131620]='Error during managed I/O.'\nComment[0x80131620]='Some sort of I/O error.'\nSymbolicName[0x80131621]='COR_E_FILELOAD'\nMessage[0x80131621]='Could not find or load a specific file.'\nSymbolicName[0x80131622]='COR_E_OBJECTDISPOSED'\nMessage[0x80131622]='The object has already been disposed.'\nComment[0x80131622]='The object has already been disposed.'\nSymbolicName[0x80131623]='COR_E_FAILFAST'\nMessage[0x80131623]='Runtime operation halted by call to System.Environment.FailFast().'\nComment[0x80131623]='Runtime operation halted by call to System.Environment.FailFast().'\nSymbolicName[0x80131640]='COR_E_HOSTPROTECTION'\nMessage[0x80131640]='The host has forbidden this operation.'\nComment[0x80131640]='Attempted to perform an operation that was forbidden by the host.'\nSymbolicName[0x80131641]='COR_E_ILLEGAL_REENTRANCY'\nMessage[0x80131641]='Attempted to call into managed code when executing inside a low level extensibility point.'\nComment[0x80131641]='Attempted to call into managed code when executing inside a low level extensibility point.'\nSymbolicName[0x80131700]='CLR_E_SHIM_RUNTIMELOAD'\nMessage[0x80131700]='Failed to load the runtime.'\nComment[0x80131700]='Failed to load the runtime'\nSymbolicName[0x80131704]='CLR_E_SHIM_LEGACYRUNTIMEALREADYBOUND'\nMessage[0x80131704]='A runtime has already been bound for legacy activation policy use.'\nSymbolicName[0x80131815]='VER_E_FIELD_SIG'\nMessage[0x80131815]='[field sig]'\nSymbolicName[0x801318ce]='VER_E_CIRCULAR_VAR_CONSTRAINTS'\nMessage[0x801318ce]='Method parent has circular class type parameter constraints.'\nSymbolicName[0x801318cf]='VER_E_CIRCULAR_MVAR_CONSTRAINTS'\nMessage[0x801318cf]='Method has circular method type parameter constraints.'\nSymbolicName[0x80131920]='COR_E_Data'\nSymbolicName[0x80131b24]='VLDTR_E_SIG_BADVOID'\nMessage[0x80131b24]=\"Illegal 'void' in signature.\"\nComment[0x80131b24]='Illegal \"void\" in signature'\nSymbolicName[0x80131b2d]='VLDTR_E_GP_ILLEGAL_VARIANT_MVAR'\nMessage[0x80131b2d]='GenericParam is a method type parameter and must be non-variant.'\nComment[0x80131b2d]='GenericParam is a method type parameter and must be non-variant'\nSymbolicName[0x80131c00]='CORDBG_E_THREAD_NOT_SCHEDULED'\nMessage[0x80131c00]='Thread is not scheduled. Thus we may not have OSThreadId, handle, or context.'\nComment[0x80131c00]='Thread is not scheduled. Thus we may not have OSThreadId, handle, or context'\nSymbolicName[0x80131c01]='CORDBG_E_HANDLE_HAS_BEEN_DISPOSED'\nMessage[0x80131c01]='Handle has been disposed.'\nComment[0x80131c01]='Handle has been disposed.'\nSymbolicName[0x80131c02]='CORDBG_E_NONINTERCEPTABLE_EXCEPTION'\nMessage[0x80131c02]='Cannot intercept this exception.'\nComment[0x80131c02]='Cant intercept this exception.'\nSymbolicName[0x80131c04]='CORDBG_E_INTERCEPT_FRAME_ALREADY_SET'\nMessage[0x80131c04]='The intercept frame for this exception has already been set.'\nComment[0x80131c04]='The intercept frame for this exception has already been set.'\nSymbolicName[0x80131c05]='CORDBG_E_NO_NATIVE_PATCH_AT_ADDR'\nMessage[0x80131c05]='There is no native patch at the given address.'\nComment[0x80131c05]=\"there's no native patch at the given address.\"\nSymbolicName[0x80131c06]='CORDBG_E_MUST_BE_INTEROP_DEBUGGING'\nMessage[0x80131c06]='This API is only allowed when interop debugging.'\nComment[0x80131c06]='This API is only allowed when interop debugging.'\nSymbolicName[0x80131c07]='CORDBG_E_NATIVE_PATCH_ALREADY_AT_ADDR'\nMessage[0x80131c07]='There is already a native patch at the address.'\nComment[0x80131c07]=\"There's already a native patch at the address\"\nSymbolicName[0x80131c08]='CORDBG_E_TIMEOUT'\nMessage[0x80131c08]='A wait timed out, likely an indication of deadlock.'\nComment[0x80131c08]='a wait timed out .. likely an indication of deadlock.'\nSymbolicName[0x80131c09]='CORDBG_E_CANT_CALL_ON_THIS_THREAD'\nMessage[0x80131c09]='Cannot use the API on this thread.'\nComment[0x80131c09]=\"Can't use the API on this thread.\"\nSymbolicName[0x80131c0a]='CORDBG_E_ENC_INFOLESS_METHOD'\nMessage[0x80131c0a]=\"Method was not JIT'd in EnC mode.\"\nComment[0x80131c0a]='Method was not JITed in EnC mode'\nSymbolicName[0x80131c0c]='CORDBG_E_ENC_IN_FUNCLET'\nMessage[0x80131c0c]='Method is in a callable handler/filter. Cannot increase stack.'\nComment[0x80131c0c]='Method is in a callable handler/filter. Cant grow stack'\nSymbolicName[0x80131c0e]='CORDBG_E_ENC_EDIT_NOT_SUPPORTED'\nMessage[0x80131c0e]='Attempt to perform unsupported edit.'\nComment[0x80131c0e]='Attempt to perform unsupported edit'\nSymbolicName[0x80131c10]='CORDBG_E_NOTREADY'\nMessage[0x80131c10]='The LS is not in a good spot to perform the requested operation.'\nComment[0x80131c10]='The LS is not in a good spot to perform the requested operation.'\nSymbolicName[0x80131c11]='CORDBG_E_CANNOT_RESOLVE_ASSEMBLY'\nMessage[0x80131c11]='We failed to resolve assembly given an AssemblyRef token. Assembly may be not loaded yet or not a valid token.'\nComment[0x80131c11]='We failed to resolve assembly given an AssemblyRef token. Assembly may be not loaded yet or not a valid token.'\nSymbolicName[0x80131c12]='CORDBG_E_MUST_BE_IN_LOAD_MODULE'\nMessage[0x80131c12]='Must be in context of LoadModule callback to perform requested operation.'\nComment[0x80131c12]='Must be in context of LoadModule callback to perform requested operation'\nSymbolicName[0x80131c13]='CORDBG_E_CANNOT_BE_ON_ATTACH'\nMessage[0x80131c13]='Requested operation cannot be performed during an attach operation.'\nComment[0x80131c13]='Requested operation cannot be performed during an attach operation'\nSymbolicName[0x80131c14]='CORDBG_E_NGEN_NOT_SUPPORTED'\nMessage[0x80131c14]='NGEN must be supported to perform the requested operation.'\nComment[0x80131c14]='NGEN must be supported to perform the requested operation'\nSymbolicName[0x80131c15]='CORDBG_E_ILLEGAL_SHUTDOWN_ORDER'\nMessage[0x80131c15]='Trying to shutdown out of order.'\nComment[0x80131c15]='Trying to shutdown out of order.'\nSymbolicName[0x80131c16]='CORDBG_E_CANNOT_DEBUG_FIBER_PROCESS'\nMessage[0x80131c16]='Debugging fiber mode managed process is not supported.'\nComment[0x80131c16]=\"For Whidbey, we don't support debugging fiber mode managed process\"\nSymbolicName[0x80131c17]='CORDBG_E_MUST_BE_IN_CREATE_PROCESS'\nMessage[0x80131c17]='Must be in context of CreateProcess callback to perform requested operation.'\nComment[0x80131c17]='Must be in context of CreateProcess callback to perform requested operation'\nSymbolicName[0x80131c18]='CORDBG_E_DETACH_FAILED_OUTSTANDING_EVALS'\nMessage[0x80131c18]='All outstanding func-evals have not completed, detaching is not allowed at this time.'\nComment[0x80131c18]='All outstanding func-evals have not completed, detaching is not allowed at this time.'\nSymbolicName[0x80131c19]='CORDBG_E_DETACH_FAILED_OUTSTANDING_STEPPERS'\nMessage[0x80131c19]='All outstanding steppers have not been closed, detaching is not allowed at this time.'\nComment[0x80131c19]='All outstanding steppers have not been closed, detaching is not allowed at this time.'\nSymbolicName[0x80131c20]='CORDBG_E_CANT_INTEROP_STEP_OUT'\nMessage[0x80131c20]='Cannot have an ICorDebugStepper do a native step-out.'\nComment[0x80131c20]=\"Can't have an ICorDebugStepper do a native step-out.\"\nSymbolicName[0x80131c21]='CORDBG_E_DETACH_FAILED_OUTSTANDING_BREAKPOINTS'\nMessage[0x80131c21]='All outstanding breakpoints have not been closed, detaching is not allowed at this time.'\nComment[0x80131c21]='All outstanding breakpoints have not been closed, detaching is not allowed at this time.'\nSymbolicName[0x80131c22]='CORDBG_E_ILLEGAL_IN_STACK_OVERFLOW'\nMessage[0x80131c22]='The operation is illegal because of a stack overflow.'\nComment[0x80131c22]='the operation is illegal because of a stackoverflow.'\nSymbolicName[0x80131c23]='CORDBG_E_ILLEGAL_AT_GC_UNSAFE_POINT'\nMessage[0x80131c23]='The operation failed because it is a GC unsafe point.'\nComment[0x80131c23]=\"The operation failed because it's a GC unsafe point.\"\nSymbolicName[0x80131c24]='CORDBG_E_ILLEGAL_IN_PROLOG'\nMessage[0x80131c24]='The operation failed because the thread is in the prolog.'\nComment[0x80131c24]='The operation failed because the thread is in the prolog'\nSymbolicName[0x80131c25]='CORDBG_E_ILLEGAL_IN_NATIVE_CODE'\nMessage[0x80131c25]='The operation failed because the thread is in native code.'\nComment[0x80131c25]='The operation failed because the thread is in native code'\nSymbolicName[0x80131c26]='CORDBG_E_ILLEGAL_IN_OPTIMIZED_CODE'\nMessage[0x80131c26]='The operation failed because the thread is in optimized code.'\nComment[0x80131c26]='The operation failed because the thread is in optimized code.'\nSymbolicName[0x80131c28]='CORDBG_E_APPDOMAIN_MISMATCH'\nMessage[0x80131c28]='A supplied object or type belongs to the wrong AppDomain.'\nComment[0x80131c28]='A supplied object or type belongs to the wrong AppDomain'\nSymbolicName[0x80131c29]='CORDBG_E_CONTEXT_UNVAILABLE'\nMessage[0x80131c29]=\"The thread's context is not available.\"\nComment[0x80131c29]=\"The thread's context is not available.\"\nSymbolicName[0x80131c30]='CORDBG_E_UNCOMPATIBLE_PLATFORMS'\nMessage[0x80131c30]='The operation failed because debuggee and debugger are on incompatible platforms.'\nComment[0x80131c30]='The operation failed because debuggee and debugger are on incompatible platform'\nSymbolicName[0x80131c31]='CORDBG_E_DEBUGGING_DISABLED'\nMessage[0x80131c31]='The operation failed because the debugging has been disabled'\nComment[0x80131c31]='The operation failed because the debugging has been disabled'\nSymbolicName[0x80131c32]='CORDBG_E_DETACH_FAILED_ON_ENC'\nMessage[0x80131c32]='Detach is illegal after an Edit and Continue on a module.'\nComment[0x80131c32]='Detach is illegal after a module has been EnCed.'\nSymbolicName[0x80131c33]='CORDBG_E_CURRENT_EXCEPTION_IS_OUTSIDE_CURRENT_EXECUTION_SCOPE'\nMessage[0x80131c33]='Cannot intercept the current exception at the specified frame.'\nComment[0x80131c33]='Interception of the current exception is not legal'\nSymbolicName[0x80131c34]='CORDBG_E_HELPER_MAY_DEADLOCK'\nMessage[0x80131c34]='The debugger helper thread cannot obtain the locks it needs to perform this operation.'\nComment[0x80131c34]='Helper thread can not safely run code. The opereration may work at a later time.'\nSymbolicName[0x80131c35]='CORDBG_E_MISSING_METADATA'\nMessage[0x80131c35]='The operation failed because the debugger could not get the metadata.'\nComment[0x80131c35]='The operation failed because the debugger could not get the metadata.'\nSymbolicName[0x80131c36]='CORDBG_E_TARGET_INCONSISTENT'\nMessage[0x80131c36]='The debuggee is in a corrupt state.'\nComment[0x80131c36]='The debuggee is in a corrupt state.'\nSymbolicName[0x80131c37]='CORDBG_E_DETACH_FAILED_OUTSTANDING_TARGET_RESOURCES'\nMessage[0x80131c37]='Detach failed because there are outstanding resources in the target.'\nComment[0x80131c37]='The debugger is holding resource in the target (such as GC handles, function evaluations, etc).\\n  These resources must be released through the appropriate ICorDebug API before detach can succeed.'\nSymbolicName[0x80131c38]='CORDBG_E_TARGET_READONLY'\nMessage[0x80131c38]='The debuggee is read-only.'\nComment[0x80131c38]='The provided ICorDebugDataTarget does not implement ICorDebugMutableDataTarget.'\nSymbolicName[0x80131c39]='CORDBG_E_MISMATCHED_CORWKS_AND_DACWKS_DLLS'\nMessage[0x80131c39]='The version of clr.dll in the target does not match the one mscordacwks.dll was built for.'\nComment[0x80131c39]='A clr/mscordacwks mismatch will cause DAC to fail to initialize in ClrDataAccess::Initialize'\nSymbolicName[0x80131c3a]='CORDBG_E_MODULE_LOADED_FROM_DISK'\nMessage[0x80131c3a]='Symbols are not supplied for modules loaded from disk.'\nComment[0x80131c3a]='Symbols are not supplied for modules loaded from disk'\nSymbolicName[0x80131c3b]='CORDBG_E_SYMBOLS_NOT_AVAILABLE'\nMessage[0x80131c3b]='The application did not supply symbols when it loaded or created this module, or they are not yet available.'\nComment[0x80131c3b]='The application did not supply symbols when it loaded or created this module, or they are not yet available'\nSymbolicName[0x80131c3c]='CORDBG_E_DEBUG_COMPONENT_MISSING'\nMessage[0x80131c3c]='A debug component is not installed.'\nComment[0x80131c3c]='A debug component is not installed'\nSymbolicName[0x80131c43]='CORDBG_E_LIBRARY_PROVIDER_ERROR'\nMessage[0x80131c43]='The ICLRDebuggingLibraryProvider callback returned an error or did not provide a valid handle.'\nComment[0x80131c43]='The ICLRDebuggingLibraryProvider callback returned an error or did not provide a valid handle'\nSymbolicName[0x80131c44]='CORDBG_E_NOT_CLR'\nMessage[0x80131c44]='The module at the base address indicated was not recognized as a CLR'\nComment[0x80131c44]='The module at the base address indicated was not recognized as a CLR'\nSymbolicName[0x80131c45]='CORDBG_E_MISSING_DATA_TARGET_INTERFACE'\nMessage[0x80131c45]='The provided data target does not implement the required interfaces for this version of the runtime'\nComment[0x80131c45]='The provided data target does not implement the required interfaces for this version of the runtime'\nSymbolicName[0x80131c46]='CORDBG_E_UNSUPPORTED_DEBUGGING_MODEL'\nMessage[0x80131c46]='This debugging model is unsupported by the specified runtime'\nComment[0x80131c46]='This debugging model is unsupported by the specified runtime'\nSymbolicName[0x80131c47]='CORDBG_E_UNSUPPORTED_FORWARD_COMPAT'\nMessage[0x80131c47]='The debugger is not designed to support the version of the CLR the debuggee is using.'\nComment[0x80131c47]='The debugger is not designed to support the version of the CLR the debuggee is using.'\nSymbolicName[0x80131c48]='CORDBG_E_UNSUPPORTED_VERSION_STRUCT'\nMessage[0x80131c48]='The version struct has an unrecognized value for wStructVersion'\nComment[0x80131c48]='The version struct has an unrecognized value for wStructVersion'\nSymbolicName[0x80131c49]='CORDBG_E_READVIRTUAL_FAILURE'\nMessage[0x80131c49]='A call into a ReadVirtual implementation returned failure'\nComment[0x80131c49]='A call into a ReadVirtual implementation returned failure'\nSymbolicName[0x80131c4a]='CORDBG_E_VALUE_POINTS_TO_FUNCTION'\nMessage[0x80131c4a]=\"The Debugging API doesn't support dereferencing function pointers.\"\nComment[0x80131c4a]=\"The Debugging API doesn't support dereferencing function pointers.\"\nSymbolicName[0x80131c4b]='CORDBG_E_CORRUPT_OBJECT'\nMessage[0x80131c4b]='The address provided does not point to a valid managed object.'\nComment[0x80131c4b]='The address provided does not point to a valid managed object.'\nSymbolicName[0x80131c4c]='CORDBG_E_GC_STRUCTURES_INVALID'\nMessage[0x80131c4c]='The GC heap structures are not in a valid state for traversal.'\nComment[0x80131c4c]='The GC heap structures are not in a valid state for traversal.'\nSymbolicName[0x80131c4d]='CORDBG_E_INVALID_OPCODE'\nMessage[0x80131c4d]='The specified IL offset or opcode is not supported for this operation.'\nComment[0x80131c4d]='The specified IL offset or opcode is not supported for this operation.'\nSymbolicName[0x80131c4e]='CORDBG_E_UNSUPPORTED'\nMessage[0x80131c4e]='The specified action is unsupported by this version of the runtime.'\nComment[0x80131c4e]='The specified action is unsupported by this version of the runtime.'\nSymbolicName[0x80131c4f]='CORDBG_E_MISSING_DEBUGGER_EXPORTS'\nMessage[0x80131c4f]='The debuggee memory space does not have the expected debugging export table.'\nComment[0x80131c4f]='The debuggee memory space does not have the expected debugging export table.'\nSymbolicName[0x80131c61]='CORDBG_E_DATA_TARGET_ERROR'\nMessage[0x80131c61]='Failure when calling a data target method.'\nComment[0x80131c61]='Failure when calling a data target method.'\nSymbolicName[0x80131c64]='CORDBG_E_NO_IMAGE_AVAILABLE'\nMessage[0x80131c64]=\"Couldn't find a native image.\"\nComment[0x80131c64]=\"Couldn't find a native image.\"\nSymbolicName[0x80131c68]='CORDBG_E_UNSUPPORTED_DELEGATE'\nMessage[0x80131c68]='The delegate contains a delegate currently not supported by the API.'\nComment[0x80131c68]='The delegate contains a delegate currently not supported by the API.'\nSymbolicName[0x80131d02]='PEFMT_E_64BIT'\nMessage[0x80131d02]='File is PE32+.'\nComment[0x80131d02]='File is PE32+'\nSymbolicName[0x80131d0b]='PEFMT_E_32BIT'\nMessage[0x80131d0b]='File is PE32'\nComment[0x80131d0b]='File is PE32'\nSymbolicName[0x80131f06]='NGEN_E_SYS_ASM_NI_MISSING'\nMessage[0x80131f06]='NGen cannot proceed because Mscorlib.dll does not have a native image'\nComment[0x80131f06]='Compiling any assembly other than mscorlib in the absence of mscorlib.ni.dll is not allowed.'\nSymbolicName[0x80131fff]='CLDB_E_INTERNALERROR'\nSymbolicName[0x80132000]='CLR_E_BIND_ASSEMBLY_VERSION_TOO_LOW'\nMessage[0x80132000]='The bound assembly has a version that is lower than that of the request.'\nComment[0x80132000]='For AppX binder, indicates that bound assembly has a version lower than that requested, and we will refuse version rollback.'\nSymbolicName[0x80132001]='CLR_E_BIND_ASSEMBLY_PUBLIC_KEY_MISMATCH'\nMessage[0x80132001]='The assembly version has a public key token that does not match that of the request.'\nComment[0x80132001]=\"For AppX binder, indicates that bound assembly's public key token doesn't match the key in the assembly name.\"\nSymbolicName[0x80132002]='CLR_E_BIND_IMAGE_UNAVAILABLE'\nMessage[0x80132002]='The requested image was not found or is unavailable.'\nComment[0x80132002]='Occurs if a request for a native image is made on an ICLRPrivAssembly interface when one is not available.'\nSymbolicName[0x80132003]='CLR_E_BIND_UNRECOGNIZED_IDENTITY_FORMAT'\nMessage[0x80132003]='The provided identity format is not recognized.'\nComment[0x80132003]='If a binder is provided an identity format that it cannot parse, it returns this error.'\nSymbolicName[0x80132004]='CLR_E_BIND_ASSEMBLY_NOT_FOUND'\nMessage[0x80132004]='A binding for the specified assembly name was not found.'\nComment[0x80132004]='Returned by binders that bind based on assembly identity.'\nSymbolicName[0x80132005]='CLR_E_BIND_TYPE_NOT_FOUND'\nMessage[0x80132005]='A binding for the specified type name was not found.'\nComment[0x80132005]='Returned by binders that bind based on type identity.'\nSymbolicName[0x80132006]='CLR_E_BIND_SYS_ASM_NI_MISSING'\nMessage[0x80132006]='Could not use native image because Mscorlib.dll is missing a native image'\nComment[0x80132006]='Returned when loading an assembly that only has a native image and no IL and cannot hardbind to mscorlib.ni.dll.'\nSymbolicName[0x80132007]='CLR_E_BIND_NI_SECURITY_FAILURE'\nMessage[0x80132007]='Native image was generated in a different trust level than present at runtime'\nComment[0x80132007]='Returned when an assembly is NGened in full trust and then used in partial trust or vice versa.'\nSymbolicName[0x80132008]='CLR_E_BIND_NI_DEP_IDENTITY_MISMATCH'\nMessage[0x80132008]='Native image identity mismatch with respect to its dependencies'\nComment[0x80132008]=\"Returned when an assembly's identities have changed so the native image is no longer valid.\"\nSymbolicName[0x80132009]='CLR_E_GC_OOM'\nMessage[0x80132009]='Failfast due to an OOM during a GC'\nComment[0x80132009]='During a GC when we try to allocate memory for GC datastructures we could not.'\nSymbolicName[0x8013200a]='CLR_E_GC_BAD_AFFINITY_CONFIG'\nMessage[0x8013200a]=\"GCHeapAffinitizeMask or GCHeapAffinitizeRanges didn't specify any CPUs the current process is affinitized to.\"\nComment[0x8013200a]=\"During a GC initialization, the affinity mask specified via GCHeapAffinitizeMask or GCHeapAffinitizeRanges didn't contain any CPUs the current process is affinitized to.\"\nSymbolicName[0x8013200b]='CLR_E_GC_BAD_AFFINITY_CONFIG_FORMAT'\nMessage[0x8013200b]='GCHeapAffinitizeRanges configuration string has invalid format.'\nComment[0x8013200b]=\"During a GC initialization, the GCHeapAffinitizeRanges config couldn't be parsed due to its invalid format.\"\nSymbolicName[0x8013200c]='CLR_E_CROSSGEN_NO_IBC_DATA_FOUND'\nMessage[0x8013200c]='Cannot compile using the PartialNgen flag because no IBC data was found.'\nComment[0x8013200c]='During crossgen compilation, the PartialNgen flag was set, but no IBC data was found in the resources section of the input image, and no IBC file was externally provided.'\n", ["clr_loader.util.clr_error", "sys", "typing", "xml.etree"]], "clr_loader.util.find": [".py", "import os\nimport platform\nimport shutil\nimport sys\nfrom pathlib import Path\nfrom typing import Iterator,Optional\n\nfrom .runtime_spec import DotnetCoreRuntimeSpec\n\n\ndef find_dotnet_cli()->Optional[Path]:\n dotnet_path=shutil.which(\"dotnet\")\n if not dotnet_path:\n  return None\n else :\n  return Path(dotnet_path)\n  \n  \ndef find_dotnet_root()->Path:\n ''\n\n\n\n\n\n\n\n\n\n\n \n \n dotnet_root=os.environ.get(\"DOTNET_ROOT\",None )\n if dotnet_root is not None :\n  return Path(dotnet_root)\n  \n if sys.platform ==\"win32\":\n \n  prog_files=os.environ.get(\"ProgramFiles\")\n  if not prog_files:\n   raise RuntimeError(\"Could not find ProgramFiles\")\n  prog_files=Path(prog_files)\n  dotnet_root=prog_files /\"dotnet\"\n elif sys.platform ==\"darwin\":\n  if \"ARM64\"in os.uname().version and platform.machine()==\"x86_64\":\n  \n   dotnet_root=Path(\"/usr/local/share/dotnet/x64\")\n  else :\n   dotnet_root=Path(\"/usr/local/share/dotnet\")\n   \n if dotnet_root is not None and dotnet_root.is_dir():\n  return dotnet_root\n  \n  \n dotnet_cli=find_dotnet_cli()\n if not dotnet_cli:\n  raise RuntimeError(\"Can not determine dotnet root\")\n  \n return dotnet_cli.resolve().parent\n \n \ndef find_runtimes_using_cli(dotnet_cli:Path)->Iterator[DotnetCoreRuntimeSpec]:\n import re\n from subprocess import check_output\n \n out=check_output([str(dotnet_cli),\"--list-runtimes\"],encoding=\"UTF8\")\n runtime_re=re.compile(r\"(?P<name>\\S+) (?P<version>\\S+) \\[(?P<path>[^\\]]+)\\]\")\n \n for line in out.splitlines():\n  m=re.match(runtime_re,line)\n  if m:\n   path=Path(m.group(\"path\"))\n   version=m.group(\"version\")\n   if path.is_dir():\n    yield DotnetCoreRuntimeSpec(m.group(\"name\"),version,path /version)\n    \n    \ndef find_runtimes_in_root(dotnet_root:Path)->Iterator[DotnetCoreRuntimeSpec]:\n shared=dotnet_root /\"shared\"\n for runtime in shared.iterdir():\n  if runtime.is_dir():\n   name=runtime.name\n   for version_path in runtime.iterdir():\n    if version_path.is_dir():\n     yield DotnetCoreRuntimeSpec(name,version_path.name,version_path)\n     \n     \ndef find_runtimes()->Iterator[DotnetCoreRuntimeSpec]:\n ''\n\n\n\n\n\n\n\n\n\n \n dotnet_cli=find_dotnet_cli()\n if dotnet_cli is not None :\n  return find_runtimes_using_cli(dotnet_cli)\n else :\n  dotnet_root=find_dotnet_root()\n  return find_runtimes_in_root(dotnet_root)\n  \n  \ndef find_libmono(*,sgen:bool=True )->Path:\n ''\n\n\n\n\n\n\n\n\n\n \n unix_name=f\"mono{'sgen' if sgen else ''}-2.0\"\n if sys.platform ==\"win32\":\n  if sys.maxsize >2 **32:\n   prog_files=os.environ.get(\"ProgramFiles\")\n  else :\n   prog_files=os.environ.get(\"ProgramFiles(x86)\")\n   \n  if prog_files is None :\n   raise RuntimeError(\"Could not determine Program Files location\")\n   \n   \n  path=Path(prog_files)/\"Mono/bin/mono-2.0-sgen.dll\"\n  \n elif sys.platform ==\"darwin\":\n  path=(\n  Path(\"/Library/Frameworks/Mono.framework/Versions/Current/lib\")\n  /f\"lib{unix_name}.dylib\"\n  )\n  \n else :\n  from ctypes.util import find_library\n  \n  path=find_library(unix_name)\n  \n if path is None :\n  raise RuntimeError(\"Could not find libmono\")\n  \n return Path(path)\n", ["clr_loader.util.runtime_spec", "ctypes.util", "os", "pathlib", "platform", "re", "shutil", "subprocess", "sys", "typing"]], "clr_loader.util.hostfxr_errors": [".py", "from typing import Optional\n\nfrom .clr_error import ClrError\n\n__all__=[\"get_hostfxr_error\"]\n\n\ndef get_hostfxr_error(hresult:int)->Optional[ClrError]:\n if hresult in HOSTFXR_ERRORS:\n  return ClrError(hresult,HOSTFXR_ERRORS[hresult])\n else :\n  return None\n  \n  \n_ERRORS=dict(\nSuccess=0,\nSuccess_HostAlreadyInitialized=0x00000001,\nSuccess_DifferentRuntimeProperties=0x00000002,\n\nInvalidArgFailure=0x80008081,\nCoreHostLibLoadFailure=0x80008082,\nCoreHostLibMissingFailure=0x80008083,\nCoreHostEntryPointFailure=0x80008084,\nCoreHostCurHostFindFailure=0x80008085,\n\nCoreClrResolveFailure=0x80008087,\nCoreClrBindFailure=0x80008088,\nCoreClrInitFailure=0x80008089,\nCoreClrExeFailure=0x8000808A,\nResolverInitFailure=0x8000808B,\nResolverResolveFailure=0x8000808C,\nLibHostCurExeFindFailure=0x8000808D,\nLibHostInitFailure=0x8000808E,\n\nLibHostExecModeFailure=0x80008090,\nLibHostSdkFindFailure=0x80008091,\nLibHostInvalidArgs=0x80008092,\nInvalidConfigFile=0x80008093,\nAppArgNotRunnable=0x80008094,\nAppHostExeNotBoundFailure=0x80008095,\nFrameworkMissingFailure=0x80008096,\nHostApiFailed=0x80008097,\nHostApiBufferTooSmall=0x80008098,\nLibHostUnknownCommand=0x80008099,\nLibHostAppRootFindFailure=0x8000809A,\nSdkResolverResolveFailure=0x8000809B,\nFrameworkCompatFailure=0x8000809C,\nFrameworkCompatRetry=0x8000809D,\n\nBundleExtractionFailure=0x8000809F,\nBundleExtractionIOError=0x800080A0,\nLibHostDuplicateProperty=0x800080A1,\nHostApiUnsupportedVersion=0x800080A2,\nHostInvalidState=0x800080A3,\nHostPropertyNotFound=0x800080A4,\nCoreHostIncompatibleConfig=0x800080A5,\n)\n\n\nHOSTFXR_ERRORS={v:k for k,v in _ERRORS.items()}\n", ["clr_loader.util.clr_error", "typing"]], "clr_loader.util.runtime_spec": [".py", "import json\nfrom dataclasses import dataclass\nfrom pathlib import Path\nfrom typing import Any,Dict,TextIO\n\n\n@dataclass\nclass DotnetCoreRuntimeSpec:\n ''\n \n name:str\n version:str\n path:Path\n \n @property\n def tfm(self)->str:\n  return f\"net{self.version[:3]}\"\n  \n @property\n def floor_version(self)->str:\n  return f\"{self.version[:3]}.0\"\n  \n @property\n def runtime_config(self)->Dict[str,Any]:\n  return {\n  \"runtimeOptions\":{\n  \"tfm\":self.tfm,\n  \"framework\":{\"name\":self.name,\"version\":self.floor_version},\n  }\n  }\n  \n def write_config(self,f:TextIO)->None :\n  json.dump(self.runtime_config,f)\n", ["dataclasses", "json", "pathlib", "typing"]], "clr_loader.util": [".py", "from pathlib import Path\nfrom typing import Optional\n\nfrom ..types import StrOrPath\nfrom .clr_error import ClrError\nfrom .coreclr_errors import get_coreclr_error\nfrom .find import find_dotnet_root\nfrom .hostfxr_errors import get_hostfxr_error\n\n__all__=[\n\"check_result\",\n\"find_dotnet_root\",\n\"path_as_string\",\n\"optional_path_as_string\",\n]\n\n\ndef optional_path_as_string(path:Optional[StrOrPath])->Optional[str]:\n if path is None :\n  return None\n return path_as_string(path)\n \n \ndef path_as_string(path:StrOrPath)->str:\n return str(Path(path))\n \n \ndef check_result(err_code:int)->None :\n ''\n\n\n\n \n \n if err_code <0:\n  hresult=err_code&0xFFFF_FFFF\n  error=get_coreclr_error(hresult)\n  if not error:\n   error=get_hostfxr_error(hresult)\n  if not error:\n   error=ClrError(hresult)\n  raise error\n", ["clr_loader.types", "clr_loader.util.clr_error", "clr_loader.util.coreclr_errors", "clr_loader.util.find", "clr_loader.util.hostfxr_errors", "pathlib", "typing"], 1]}
__BRYTHON__.update_VFS(scripts)
